<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI CoreWork - æ™ºèƒ½è¨­è¨ˆå”ä½œå¹³å°</title>
    
    <!-- KaTeX for mathematical formula rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    
    <!-- html2canvas for canvas to image conversion -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    
    <style>
        .right-panel-container {
            display: grid;
            grid-template-rows: 1fr auto 1fr;
            gap: 10px;
            height: 100%;
        }
        
        .mindmap-area {
            background: #f8f9fa;
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-style: italic;
            min-height: 200px;
        }
        
        .chat-messages {
            flex: 1; /* è‡ªå‹•å¡«å……å‰©é¤˜ç©ºé–“ */
            min-height: 200px; /* æœ€å°é«˜åº¦ */
            max-height: 50vh; /* æœ€å¤§é«˜åº¦ç‚ºè¦–çª—çš„ 50% */
            overflow-y: auto; /* å‚ç›´æ»¾å‹• */
            overflow-x: hidden; /* ç¦æ­¢æ©«å‘æ»¾å‹• */
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            background: #f8f9fa;
            font-size: 14px;
        }
        
        .panel-divider {
            height: 4px;
            background: #ddd;
            cursor: row-resize;
            border-radius: 2px;
            transition: background 0.2s;
            position: relative;
            user-select: none;
        }
        
        .panel-divider:hover {
            background: #3498db;
        }
        
        .panel-divider::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 0;
            right: 0;
            height: 8px;
            cursor: row-resize;
        }
        
        .resizable-panel {
            min-height: 100px;
            overflow: hidden;
        }
        
        /* èŠå¤©å€åŸŸ Flexbox ä½ˆå±€ */
        .chat-section {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .chat-section .panel-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow-y: auto; /* æ”¹ç‚ºå‚ç›´æ»¾å‹• */
            overflow-x: hidden;
            padding-bottom: 10px; /* ç¢ºä¿åº•éƒ¨æœ‰ç©ºé–“ */
        }
        
        /* AI è¨­å®šå€åŸŸ */
        .ai-settings {
            flex-shrink: 0; /* ä¸è¢«å£“ç¸® */
        }
        
        /* èŠå¤©è¨Šæ¯å€åŸŸåœ¨ .chat-section å…§æ™‚çš„ç‰¹æ®Šæ¨£å¼ */
        .chat-section .chat-messages {
            flex: 1; /* è‡ªå‹•å¡«å…… */
            min-height: 150px;
            max-height: none; /* ç§»é™¤æœ€å¤§é«˜åº¦é™åˆ¶ */
        }
        
        /* è¼¸å…¥æ¡†å’ŒæŒ‰éˆ• */
        .chat-section .chat-input,
        .chat-section .send-button {
            flex-shrink: 0; /* ä¸è¢«å£“ç¸® */
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            color: #2c3e50;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            color: #3498db;
            font-size: 1.8rem;
            margin-bottom: 5px;
        }
        
        .workspace {
            display: grid;
            grid-template-columns: 125px 1fr 300px;
            gap: 15px;
            margin-bottom: 20px;
            height: calc(100vh - 120px);
        }
        
        .panel {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .panel-header {
            background: #3498db;
            color: white;
            padding: 8px 12px;
            font-weight: 600;
            font-size: 14px;
        }
        
        .panel-content {
            padding: 12px;
            max-height: calc(100vh - 150px); /* å‹•æ…‹é«˜åº¦ï¼Œæ‰£é™¤ header å’Œ padding */
            overflow-y: auto; /* å‚ç›´æ»¾å‹• */
            overflow-x: hidden; /* ç¦æ­¢æ©«å‘æ»¾å‹• */
            display: flex;
            flex-direction: column; /* å‚ç›´æ’åˆ— */
            gap: 10px;
        }
        
        .drawing-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            position: relative;
            height: 500px;
        }
        
        #drawing-canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            cursor: crosshair;
            display: block;
        }
        
        .tool-group {
            margin-bottom: 0; /* ç§»é™¤ marginï¼Œæ”¹ç”¨ gap */
            width: 100%; /* å æ»¿å¯¬åº¦ */
        }
        
        .tool-group h4 {
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 12px;
            text-align: center;
        }
        
        .tool-buttons, .mode-buttons {
            display: flex;
            flex-direction: column; /* å‚ç›´æ’åˆ— */
            gap: 8px;
            width: 100%; /* å æ»¿å¯¬åº¦ */
        }
        
        .mode-buttons {
            flex-direction: row; /* æ¨¡å¼æŒ‰éˆ•æ©«å‘æ’åˆ— */
            flex-wrap: wrap; /* å…è¨±æ›è¡Œ */
        }
        
        .tool-btn, .mode-btn {
            background: #ecf0f1;
            border: 2px solid transparent;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            text-align: center;
            width: 100%; /* å æ»¿å¯¬åº¦ */
            white-space: nowrap; /* æ–‡å­—ä¸æ›è¡Œ */
            overflow: hidden; /* éš±è—æº¢å‡º */
            text-overflow: ellipsis; /* é¡¯ç¤ºçœç•¥è™Ÿ */
        }
        
        .tool-btn:hover, .mode-btn:hover {
            background: #d5dbdb;
        }
        
        .tool-btn.active, .mode-btn.active {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }
        
        .mode-btn.active[data-mode="select"] {
            background: #e67e22;
            border-color: #d35400;
        }
        
        .color-picker {
            width: 100%;
            height: 30px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 8px;
        }
        
        .color-swatches {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }
        
        .color-swatch {
            width: 100%;
            height: 25px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
            border-color: #2c3e50;
        }
        
        .size-slider {
            width: 100%;
            margin-bottom: 10px;
        }
        
        .size-display {
            text-align: center;
            font-weight: 600;
            color: #3498db;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap; /* å…è¨±æ›è¡Œ */
            width: 100%;
            flex-shrink: 0; /* é˜²æ­¢è¢«å£“ç¸® */
        }
        
        .action-buttons .btn {
            flex: 1; /* æŒ‰éˆ•å¹³å‡åˆ†é…ç©ºé–“ */
            min-width: 80px; /* æœ€å°å¯¬åº¦ */
        }
        
        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2980b9;
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }

        /* å°è©±æ¡†æ¨£å¼ */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .dialog-content {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .dialog-header {
            padding: 20px 20px 15px;
            border-bottom: 1px solid #eee;
            text-align: center;
        }

        .dialog-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 18px;
        }

        .dialog-body {
            padding: 20px;
        }

        .dialog-body p {
            margin: 0 0 20px 0;
            color: #666;
            text-align: center;
        }

        .mode-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .mode-btn {
            display: flex;
            align-items: center;
            padding: 15px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .mode-btn:hover {
            border-color: #3498db;
            background: #f8f9ff;
        }

        .mode-icon {
            font-size: 24px;
            margin-right: 15px;
            width: 30px;
            text-align: center;
        }

        .mode-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 3px;
        }

        .mode-desc {
            font-size: 12px;
            color: #666;
            line-height: 1.3;
        }

        .dialog-footer {
            padding: 15px 20px 20px;
            border-top: 1px solid #eee;
            text-align: center;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        /* .chat-messages å·²åœ¨ä¸Šæ–¹å®šç¾©ï¼Œæ­¤è™•ç§»é™¤é‡è¤‡ */
        
        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
        }
        
        .user-message {
            background: #e3f2fd;
            margin-left: 20px;
        }
        
        .ai-message {
            background: #f1f8e9;
            margin-right: 20px;
        }
        
        .chat-input {
            width: 100%;
            height: 100px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            resize: vertical;
            font-family: inherit;
        }
        
        .send-button {
            width: 100%;
            margin-top: 10px;
        }
        
        .loading-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #3498db;
            font-weight: 600;
            z-index: 1000;
        }
        
        .main-content {
            display: none;
        }
        
        @media (max-width: 1000px) {
            .workspace {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }
        
        /* AI è¨­å®šå€åŸŸ */
        .ai-settings {
            background: #f8f9fa;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .ai-settings h4 {
            margin: 0 0 12px 0;
            color: #2c3e50;
            font-size: 14px;
            font-weight: 600;
        }
        
        .ai-form-group {
            margin-bottom: 12px;
        }
        
        .ai-form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #555;
            font-weight: 500;
        }
        
        .ai-form-select,
        .ai-form-input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 13px;
            background: white;
        }
        
        .ai-form-input[type="password"] {
            font-family: monospace;
        }
        
        .ai-btn {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .ai-btn-verify {
            background: #3498db;
            color: white;
            margin-bottom: 10px;
        }
        
        .ai-btn-verify:hover {
            background: #2980b9;
        }
        
        .ai-btn-verify:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        
        .ai-status {
            padding: 8px 10px;
            border-radius: 5px;
            font-size: 12px;
            text-align: center;
            margin-top: 8px;
        }
        
        .ai-status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .ai-status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .ai-status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        /* ç¯„ä¾‹å±•ç¤ºå€åŸŸ */
        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .example-item {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .example-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .example-image {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 6px;
            margin-bottom: 10px;
            background: #ecf0f1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
        }
        
        .example-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .example-description {
            font-size: 0.9rem;
            color: #7f8c8d;
            line-height: 1.4;
        }
        
        .loading-indicator {
            text-align: center;
            padding: 20px;
            color: #3498db;
            font-size: 16px;
        }
        
        .analysis-result {
            background: #e8f5e8;
            border: 1px solid #27ae60;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .analysis-title {
            font-weight: 600;
            color: #27ae60;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <!-- è¼‰å…¥æŒ‡ç¤ºå™¨ -->
    <div id="loading" class="loading-text">ğŸ¨ è¼‰å…¥ä¸­...</div>
    
    <!-- ä¸»è¦å…§å®¹ -->
    <div id="main-content" class="main-content">
        <div class="container">
            <!-- æ¨™é¡Œ -->
            <div class="header">
                <h1>ğŸ¨ UI CoreWork</h1>
                <p>æ™ºèƒ½è¨­è¨ˆå”ä½œå¹³å° - ç¹ªåœ– & èŠå¤©</p>
            </div>
            
            <!-- ä¸»å·¥ä½œå€ -->
            <div class="workspace">
                <!-- å·¥å…·é¢æ¿ -->
                <div class="panel">
                    <div class="panel-header">ğŸ› ï¸ ç¹ªåœ–å·¥å…·</div>
                    <div class="panel-content">
                        <div class="tool-group">
                            <h4>åŠŸèƒ½</h4>
                            <button class="tool-btn function-btn" id="select-area-btn" style="width: 100%; margin-bottom: 10px; background: #95a5a6; color: white;">
                                ğŸ”² åœˆé¸å€åŸŸ
                            </button>
                            <button class="tool-btn function-btn" id="move-btn" style="width: 100%; margin-bottom: 10px; background: #95a5a6; color: white;">
                                ğŸ–ï¸ ç§»å‹•é¸å–
                            </button>
                            <button class="tool-btn function-btn" id="scale-btn" style="width: 100%; margin-bottom: 10px; background: #95a5a6; color: white;">
                                ğŸ” ç¸®æ”¾é¸å–
                            </button>
                            <button class="tool-btn function-btn" id="delete-btn" style="width: 100%; margin-bottom: 10px; background: #95a5a6; color: white;">
                                ğŸ—‘ï¸ åˆªé™¤é¸å–
                            </button>
                        </div>
                        
                        <div class="tool-group">
                            <h4>ç¹ªåœ–å·¥å…·</h4>
                            <div class="tool-buttons">
                                <button class="tool-btn active" data-tool="pen">âœï¸ ç­†</button>
                                <button class="tool-btn" data-tool="eraser">ğŸ§½ æ“¦</button>
                            </div>
                        </div>
                        
                        <div class="tool-group">
                            <h4>é¡è‰²</h4>
                            <input type="color" id="color-picker" class="color-picker" value="#2c3e50">
                            <div class="color-swatches">
                                <div class="color-swatch" style="background: #2c3e50;" data-color="#2c3e50"></div>
                                <div class="color-swatch" style="background: #e74c3c;" data-color="#e74c3c"></div>
                                <div class="color-swatch" style="background: #3498db;" data-color="#3498db"></div>
                                <div class="color-swatch" style="background: #2ecc71;" data-color="#2ecc71"></div>
                                <div class="color-swatch" style="background: #f39c12;" data-color="#f39c12"></div>
                                <div class="color-swatch" style="background: #9b59b6;" data-color="#9b59b6"></div>
                            </div>
                        </div>
                        
                        <div class="tool-group">
                            <h4>ç­†åˆ·å¤§å°</h4>
                            <input type="range" id="size-slider" class="size-slider" min="1" max="50" value="5">
                            <div id="size-display" class="size-display">5px</div>
                        </div>
                        
                        <div class="action-buttons">
                            <button id="undo-btn" class="btn btn-secondary" title="å›ä¸Šä¸€æ­¥ (Ctrl+Z)" disabled>â†©ï¸ å›ä¸Šä¸€æ­¥</button>
                            <button id="redo-btn" class="btn btn-secondary" title="é‡åš (Ctrl+Y)" disabled>â¡ï¸ é‡åš</button>
                            <button id="clear-btn" class="btn btn-danger">æ¸…é™¤</button>
                            <button id="analyze-btn" class="btn btn-primary">åˆ†æåœ–åƒ</button>
                        </div>
                        <!-- ä¸Šå‚³åœ–ç‰‡ -->
                        <input id="image-upload-input" type="file" accept="image/*" style="display:none;">
                        <div class="action-buttons">
                            <button id="upload-image-btn" class="btn btn-primary">ä¸Šå‚³åœ–ç‰‡</button>
                        </div>
                    </div>
                </div>
                
                <!-- ç¹ªåœ–å€åŸŸ -->
                <div class="panel">
                    <div class="panel-header">ğŸ¨ ç•«å¸ƒ</div>
                    <div class="panel-content">
                        <div class="drawing-area">
                            <canvas id="drawing-canvas"></canvas>
                        </div>
                        <div class="action-buttons">
                            <button id="save-btn" class="btn btn-primary">å„²å­˜ä½œå“</button>
                            <button id="save-to-project-btn" class="btn btn-primary">ä¿å­˜åˆ°é …ç›®</button>
                        </div>
                    </div>
                </div>
                
                <!-- å³å´é¢æ¿å€åŸŸ -->
                <div class="panel">
                    <div class="right-panel-container">
                        <!-- å¿ƒæ™ºåœ–å€åŸŸ -->
                        <div id="mindmap-panel" class="mindmap-section resizable-panel">
                            <div class="panel-header">ğŸ§  å¿ƒæ™ºåœ–å€åŸŸ</div>
                            <div class="mindmap-area">
                                <div>å¿ƒæ™ºåœ–åŠŸèƒ½é–‹ç™¼ä¸­...</div>
                            </div>
                        </div>
                        
                        <!-- åˆ†éš”ç·š -->
                        <div id="panel-resizer" class="panel-divider" title="æ‹–æ‹½èª¿æ•´å¤§å°"></div>
                        
                        <!-- èŠå¤©å€åŸŸ -->
                        <div id="chat-panel" class="chat-section resizable-panel">
                            <div class="panel-header">ğŸ’¬ AI åŠ©æ‰‹</div>
                            <div class="panel-content">
                                <!-- AI è¨­å®šé¢æ¿ -->
                                <div class="ai-settings">
                                    <h4>ğŸ¤– AI è¨­å®š</h4>
                                    <div class="ai-form-group">
                                        <label>AI æä¾›å•†</label>
                                        <select id="ai-provider" class="ai-form-select">
                                            <option value="">ä½¿ç”¨é è¨­ (ç’°å¢ƒè®Šæ•¸)</option>
                                            <option value="gemini">Google Gemini</option>
                                            <option value="openai">OpenAI</option>
                                        </select>
                                    </div>
                                    <div class="ai-form-group">
                                        <label>API Key</label>
                                        <input type="password" id="ai-api-key" class="ai-form-input" placeholder="è¼¸å…¥æ‚¨çš„ API Key">
                                    </div>
                                    <button id="ai-verify-btn" class="ai-btn ai-btn-verify">é©—è­‰ API Key</button>
                                    <div class="ai-form-group" id="ai-model-group" style="display: none;">
                                        <label>é¸æ“‡æ¨¡å‹</label>
                                        <select id="ai-model" class="ai-form-select">
                                            <option value="">è¼‰å…¥ä¸­...</option>
                                        </select>
                                    </div>
                                    <div id="ai-status" class="ai-status" style="display: none;"></div>
                                </div>
                                
                                <div id="chat-messages" class="chat-messages">
                                    <div class="message ai-message">
                                        <strong>AI:</strong> æ­¡è¿ä½¿ç”¨ UI CoreWorkï¼æˆ‘å¯ä»¥ï¼š<br>
                                        ğŸ¨ åˆ†ææ‚¨çš„ç¹ªåœ–<br>
                                        ğŸ” æœå°‹ç›¸é—œç¯„ä¾‹<br>
                                        ğŸ“š æä¾›è¨­è¨ˆå»ºè­°<br>
                                        è«‹é–‹å§‹ç¹ªåœ–æˆ–å‘æˆ‘æå•ï¼
                                    </div>
                                </div>
                                <textarea id="chat-input" class="chat-input" placeholder="è¼¸å…¥æ‚¨çš„è¨Šæ¯... (Enter ç™¼é€)&#10;ä¾‹å¦‚: 'è«‹åˆ†æé€™å€‹åœ–å½¢' æˆ– 'æ‰¾ä¸€äº›æŒ‰éˆ•è¨­è¨ˆç¯„ä¾‹'" style="height: 60px; font-size: 12px;"></textarea>
                                <button id="send-btn" class="btn btn-primary send-button" style="padding: 8px 12px; font-size: 12px;">ç™¼é€è¨Šæ¯</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ç¯„ä¾‹åœ–ç‰‡å±•ç¤ºå€åŸŸ -->
            <div id="examples-section" class="panel" style="display: none; margin-top: 20px;">
                <div class="panel-header">ğŸ–¼ï¸ è¨­è¨ˆç¯„ä¾‹èˆ‡å»ºè­°</div>
                <div class="panel-content">
                    <div id="examples-grid" class="examples-grid"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============ AI è¨­å®šç®¡ç† ============
        const AIConfig = {
            storage: {
                provider: localStorage.getItem('ai_provider') || '',
                apiKey: localStorage.getItem('ai_api_key') || '',
                model: localStorage.getItem('ai_model') || ''
            },
            
            save(provider, apiKey, model) {
                this.storage.provider = provider;
                this.storage.apiKey = apiKey;
                this.storage.model = model;
                localStorage.setItem('ai_provider', provider);
                localStorage.setItem('ai_api_key', apiKey);
                localStorage.setItem('ai_model', model);
            },
            
            clear() {
                this.storage = {provider: '', apiKey: '', model: ''};
                localStorage.removeItem('ai_provider');
                localStorage.removeItem('ai_api_key');
                localStorage.removeItem('ai_model');
            },
            
            getHeaders() {
                if (!this.storage.provider || !this.storage.apiKey) {
                    return {};
                }
                return {
                    'X-AI-Provider': this.storage.provider,
                    'X-API-Key': this.storage.apiKey,
                    'X-AI-Model': this.storage.model || ''
                };
            },
            
            isConfigured() {
                return !!(this.storage.provider && this.storage.apiKey);
            }
        };
        
        // AI è¨­å®šåˆå§‹åŒ–
        function initAISettings() {
            const providerSelect = document.getElementById('ai-provider');
            const apiKeyInput = document.getElementById('ai-api-key');
            const verifyBtn = document.getElementById('ai-verify-btn');
            const modelGroup = document.getElementById('ai-model-group');
            const modelSelect = document.getElementById('ai-model');
            const statusDiv = document.getElementById('ai-status');
            
            if (!providerSelect || !apiKeyInput || !verifyBtn) {
                console.warn('AI settings elements not found');
                return;
            }
            
            // è¼‰å…¥å„²å­˜çš„è¨­å®š
            if (AIConfig.storage.provider) {
                providerSelect.value = AIConfig.storage.provider;
                apiKeyInput.value = AIConfig.storage.apiKey;
                if (AIConfig.storage.model) {
                    modelGroup.style.display = 'block';
                    modelSelect.innerHTML = `<option value="${AIConfig.storage.model}">${AIConfig.storage.model}</option>`;
                    modelSelect.value = AIConfig.storage.model;
                }
            }
            
            // Provider æ”¹è®Šæ™‚æ¸…é™¤ key å’Œ model
            providerSelect.addEventListener('change', function() {
                apiKeyInput.value = '';
                modelGroup.style.display = 'none';
                statusDiv.style.display = 'none';
                AIConfig.clear();
            });
            
            // é©—è­‰æŒ‰éˆ•
            verifyBtn.addEventListener('click', async function() {
                const provider = providerSelect.value;
                const apiKey = apiKeyInput.value.trim();
                
                if (!provider) {
                    showStatus('è«‹é¸æ“‡ AI æä¾›å•†', 'error');
                    return;
                }
                
                if (!apiKey) {
                    showStatus('è«‹è¼¸å…¥ API Key', 'error');
                    return;
                }
                
                verifyBtn.disabled = true;
                verifyBtn.textContent = 'é©—è­‰ä¸­...';
                showStatus('æ­£åœ¨é©—è­‰ API Key...', 'info');
                
                try {
                    const response = await fetch('/api/validate-key', {
                        method: 'POST',
                        headers: {
                            'X-AI-Provider': provider,
                            'X-API-Key': apiKey
                        }
                    });
                    
                    const result = await response.json();
                    
                    if (result.valid && result.models) {
                        // é©—è­‰æˆåŠŸ
                        showStatus(`âœ… é©—è­‰æˆåŠŸï¼æ‰¾åˆ° ${result.models.length} å€‹å¯ç”¨æ¨¡å‹`, 'success');
                        
                        // å¡«å……æ¨¡å‹é¸å–®
                        modelSelect.innerHTML = result.models.map(m => 
                            `<option value="${m}">${m}</option>`
                        ).join('');
                        modelGroup.style.display = 'block';
                        
                        // å„²å­˜è¨­å®š
                        const selectedModel = result.models[0];
                        modelSelect.value = selectedModel;
                        AIConfig.save(provider, apiKey, selectedModel);
                        
                        addChatMessage('AI', `ğŸ‰ AI è¨­å®šæˆåŠŸï¼\næä¾›å•†ï¼š${provider}\næ¨¡å‹ï¼š${selectedModel}`);
                    } else {
                        showStatus(`âŒ é©—è­‰å¤±æ•—ï¼š${result.error || 'æœªçŸ¥éŒ¯èª¤'}`, 'error');
                        modelGroup.style.display = 'none';
                        AIConfig.clear();
                    }
                } catch (error) {
                    showStatus(`âŒ é€£æ¥å¤±æ•—ï¼š${error.message}`, 'error');
                    modelGroup.style.display = 'none';
                    AIConfig.clear();
                } finally {
                    verifyBtn.disabled = false;
                    verifyBtn.textContent = 'é©—è­‰ API Key';
                }
            });
            
            // Model é¸æ“‡æ”¹è®Šæ™‚æ›´æ–°å„²å­˜
            modelSelect.addEventListener('change', function() {
                if (AIConfig.storage.provider && AIConfig.storage.apiKey) {
                    AIConfig.save(
                        AIConfig.storage.provider,
                        AIConfig.storage.apiKey,
                        modelSelect.value
                    );
                    console.log('âœ… æ¨¡å‹å·²åˆ‡æ›è‡³:', modelSelect.value);
                    addChatMessage('AI', `âœ… æ¨¡å‹å·²åˆ‡æ›è‡³ï¼š${modelSelect.value}`);
                }
            });
            
            function showStatus(message, type) {
                statusDiv.textContent = message;
                statusDiv.className = `ai-status ${type}`;
                statusDiv.style.display = 'block';
            }
        }
        
        // è¨­ç½®é¢æ¿èª¿æ•´åŠŸèƒ½
        function setupPanelResizer() {
            const resizer = document.getElementById('panel-resizer');
            const mindMapPanel = document.getElementById('mindmap-panel');
            const chatPanel = document.getElementById('chat-panel');
            
            if (!resizer || !mindMapPanel || !chatPanel) {
                console.warn('Panel resizer elements not found');
                return;
            }
            
            let isResizing = false;
            let startY = 0;
            let startMindMapHeight = 0;
            let startChatHeight = 0;
            
            resizer.addEventListener('mousedown', function(e) {
                isResizing = true;
                startY = e.clientY;
                startMindMapHeight = mindMapPanel.offsetHeight;
                startChatHeight = chatPanel.offsetHeight;
                
                document.body.style.cursor = 'row-resize';
                document.body.style.userSelect = 'none';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;
                
                const deltaY = e.clientY - startY;
                const containerHeight = mindMapPanel.parentElement.offsetHeight;
                const resizerHeight = resizer.offsetHeight;
                const availableHeight = containerHeight - resizerHeight;
                
                let newMindMapHeight = startMindMapHeight + deltaY;
                let newChatHeight = startChatHeight - deltaY;
                
                // è¨­ç½®æœ€å°é«˜åº¦é™åˆ¶
                const minHeight = 100;
                if (newMindMapHeight < minHeight) {
                    newMindMapHeight = minHeight;
                    newChatHeight = availableHeight - minHeight;
                } else if (newChatHeight < minHeight) {
                    newChatHeight = minHeight;
                    newMindMapHeight = availableHeight - minHeight;
                }
                
                // ç¢ºä¿ç¸½é«˜åº¦ä¸è¶…éå®¹å™¨é«˜åº¦
                if (newMindMapHeight + newChatHeight > availableHeight) {
                    const ratio = availableHeight / (newMindMapHeight + newChatHeight);
                    newMindMapHeight *= ratio;
                    newChatHeight *= ratio;
                }
                
                mindMapPanel.style.height = newMindMapHeight + 'px';
                chatPanel.style.height = newChatHeight + 'px';
            });
            
            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }
        
        // ç­‰å¾… DOM è¼‰å…¥å®Œæˆ
        document.addEventListener('DOMContentLoaded', function() {
            console.log('UI CoreWork initializing...');
            console.log('Loading element:', document.getElementById('loading'));
            console.log('Main content element:', document.getElementById('main-content'));
            
            // éš±è—è¼‰å…¥æŒ‡ç¤ºå™¨ï¼Œé¡¯ç¤ºä¸»è¦å…§å®¹
            setTimeout(() => {
                const loadingEl = document.getElementById('loading');
                const mainContentEl = document.getElementById('main-content');
                
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                    console.log('Loading hidden');
                } else {
                    console.error('Loading element not found!');
                }
                
                if (mainContentEl) {
                    mainContentEl.style.display = 'block';
                    console.log('Main content shown');
                    initializeApp();
                } else {
                    console.error('Main content element not found!');
                }
            }, 500);
        });
        
        // ===== å…¨å±€å‡½æ•¸è²æ˜ =====
        
        // èŠå¤©æ¶ˆæ¯å‡½æ•¸
        function addChatMessage(sender, message) {
            const chatMessages = document.getElementById('chat-messages');
            if (!chatMessages) {
                console.warn('Chat messages element not found');
                return;
            }
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + (sender === 'AI' ? 'ai-message' : 'user-message');
            messageDiv.innerHTML = '<strong>' + sender + ':</strong> ';
            const span = document.createElement('span');
            span.textContent = ' ' + message;
            messageDiv.appendChild(span);
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // ç¹ªè£½é¸æ“‡çŸ©å½¢
        function drawSelectionRect() {
            if (!ctx || !canvas) return; // æª¢æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–
            
            redrawCanvas();
            
            // ç¹ªè£½é¸æ“‡çŸ©å½¢
            ctx.save();
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(
                selectionStart.x,
                selectionStart.y,
                selectionEnd.x - selectionStart.x,
                selectionEnd.y - selectionStart.y
            );
            ctx.restore();
        }
        
        // â­ å„ªåŒ–ç‰ˆï¼šé‡ç¹ªç•«å¸ƒï¼ˆæ”¯æ´ Layer é †åºï¼‰
        function redrawCanvas() {
            if (!ctx || !canvas) return; // æª¢æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // â­ æ–°çš„åœ–å±¤é †åºï¼ˆå¾åº•åˆ°é ‚ï¼‰ï¼š
            // 1. èƒŒæ™¯ï¼ˆå¦‚æœæœ‰ï¼‰
            // 2. ä¸Šå‚³çš„åœ–ç‰‡ï¼ˆimages é™£åˆ—ï¼‰
            // 3. æ•¸å­¸å…¬å¼ï¼ˆæŒ‰ layerOrderï¼‰
            // 4. æ–°çš„ç­†ç•«ï¼ˆstrokes é™£åˆ—ï¼Œæ’é™¤æ•¸å­¸å…¬å¼ï¼‰- ç¢ºä¿ç¹ªç•«åœ¨æœ€ä¸Šå±¤
            
            // === ç¬¬ä¸€å±¤ï¼šèƒŒæ™¯ï¼ˆç›®å‰ç‚ºç©ºç™½ï¼‰===
            // æœªä¾†å¯åœ¨æ­¤æ·»åŠ èƒŒæ™¯åœ–æˆ–èƒŒæ™¯è‰²
            
            // === ç¬¬äºŒå±¤ï¼šä¸Šå‚³çš„åœ–ç‰‡ï¼ˆç¬¬ä¸‰å±¤ - åœ¨å…¬å¼ä¹‹ä¸‹ï¼‰===
            images.forEach(image => {
                ctx.save();
                if (image.img) {
                    ctx.drawImage(image.img, image.x, image.y, image.width, image.height);
                } else if (image.imageData) {
                    if (!image._imgCache) {
                        image._imgCache = new Image();
                        image._imgCache.onload = function() {
                            image.img = image._imgCache;
                            ctx.drawImage(image.img, image.x, image.y, image.width, image.height);
                        };
                        image._imgCache.src = image.imageData;
                    } else if (image._imgCache.complete) {
                        image.img = image._imgCache;
                        ctx.drawImage(image.img, image.x, image.y, image.width, image.height);
                    }
                } else if (image.color) {
                    // æ¸¬è©¦å…§å®¹ï¼šç¹ªè£½å½©è‰²çŸ©å½¢
                    ctx.fillStyle = image.color;
                    ctx.fillRect(image.x, image.y, image.width, image.height);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(image.x, image.y, image.width, image.height);

                    // å¦‚æœæœ‰æ–‡æœ¬ï¼ˆå¦‚å…¬å¼ï¼‰ï¼Œç¹ªè£½æ–‡æœ¬
                    if (image.text) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(image.text,
                                   image.x + image.width/2,
                                   image.y + image.height/2);
                    }
                }
                ctx.restore();
            });

            // === ç¬¬ä¸‰å±¤ï¼šæ•¸å­¸å…¬å¼ï¼ˆç¬¬äºŒå±¤ - åœ¨åœ–ç‰‡ä¹‹ä¸Šï¼Œç­†ç•«ä¹‹ä¸‹ï¼‰===
            layerOrder.forEach(formulaId => {
                const formulaObj = formulaObjects.get(formulaId);
                if (formulaObj && formulaObj.stroke && formulaObj.stroke.image) {
                    const stroke = formulaObj.stroke;
                    ctx.save();
                    ctx.drawImage(stroke.image, stroke.x, stroke.y, stroke.width, stroke.height);
                    ctx.restore();
                }
            });

            // === ç¬¬å››å±¤ï¼šæ–°çš„ç­†ç•«ï¼ˆæœ€ä¸Šå±¤ - ç¢ºä¿ç¹ªç•«åœ¨æœ€å‰é¢ï¼‰===
            strokes.forEach(stroke => {
                // è·³éæ•¸å­¸å…¬å¼ï¼Œå·²åœ¨ä¸Šé¢æ¸²æŸ“
                if (stroke.type === 'math_formula' || (stroke.tool === 'image' && stroke.id)) {
                    return;
                }
                
                // åŸæœ‰çš„ç­†ç•«ç¹ªè£½é‚è¼¯
                if (stroke.points && stroke.points.length < 2) return;
                
                ctx.save();
                ctx.globalCompositeOperation = stroke.tool === 'eraser' ? 'destination-out' : 'source-over';
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.lineWidth = stroke.size;
                ctx.strokeStyle = stroke.color;
                
                ctx.beginPath();
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                
                for (let i = 1; i < stroke.points.length; i++) {
                    ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                }
                
                ctx.stroke();
                ctx.restore();
            });
            
            // â­ ç¹ªè£½ç¸®æ”¾é‚Šç•Œæ¡†
            drawScalingBounds();
        }
        
        // è™•ç†é¸ä¸­å€åŸŸ
        // ï¼ˆåˆªé™¤é‡è¤‡ï¼‰processSelection çš„å®Œæ•´å¯¦ä½œè¦‹å¾Œæ–‡
        
        // é¡¯ç¤ºé¸æ“‡è™•ç†é¸é …ï¼ˆä½¿ç”¨çµ•å°å®šä½æµ®å‹•æŒ‰éˆ•ï¼‰
        function showSelectionOptions(selection, imageBase64) {
            console.log('ğŸ¨ showSelectionOptions è¢«èª¿ç”¨');
            console.log('   é¸æ“‡å€åŸŸ:', selection);
            console.log('   åœ–ç‰‡æ•¸æ“šå­˜åœ¨:', !!imageBase64);
            
            // ç§»é™¤ä»»ä½•ç¾æœ‰çš„é¸æ“‡æŒ‰éˆ•
            removeSelectionButtons();
            
            // å‰µå»ºæµ®å‹•æŒ‰éˆ•å®¹å™¨
            const buttonContainer = document.createElement('div');
            buttonContainer.id = 'selection-buttons';
            buttonContainer.style.cssText = `
                position: absolute;
                background: white;
                border: 2px solid #007bff;
                border-radius: 8px;
                padding: 12px;
                box-shadow: 0 6px 20px rgba(0,0,0,0.15);
                z-index: 1000;
                display: flex;
                flex-direction: column;
                gap: 10px;
                min-width: 220px;
                font-family: Arial, sans-serif;
            `;
            
            // è¨ˆç®—æŒ‰éˆ•ä½ç½®ï¼ˆç›¸å°æ–¼ç•«å¸ƒå®¹å™¨ï¼‰
            const canvasRect = canvas.getBoundingClientRect();
            const containerRect = canvas.parentElement.getBoundingClientRect();
            
            // åˆå§‹ä½ç½®ï¼šé¸æ“‡æ¡†å³å´
            let buttonX = selection.x + selection.width + 15;
            let buttonY = selection.y;
            
            // æ™ºèƒ½ä½ç½®èª¿æ•´
            const buttonWidth = 220;
            const buttonHeight = 180;
            
            // å¦‚æœå³å´ç©ºé–“ä¸å¤ ï¼Œæ”¾åœ¨å·¦å´
            if (buttonX + buttonWidth > canvas.width) {
                buttonX = selection.x - buttonWidth - 15;
            }
            
            // å¦‚æœå·¦å´ä¹Ÿä¸å¤ ï¼Œæ”¾åœ¨é¸æ“‡æ¡†ä¸‹æ–¹
            if (buttonX < 0) {
                buttonX = selection.x;
                buttonY = selection.y + selection.height + 15;
            }
            
            // å¦‚æœä¸‹æ–¹ç©ºé–“ä¸å¤ ï¼Œæ”¾åœ¨ä¸Šæ–¹
            if (buttonY + buttonHeight > canvas.height) {
                buttonY = selection.y - buttonHeight - 15;
            }
            
            // ç¢ºä¿ä¸è¶…å‡ºé‚Šç•Œ
            buttonX = Math.max(10, Math.min(buttonX, canvas.width - buttonWidth - 10));
            buttonY = Math.max(10, Math.min(buttonY, canvas.height - buttonHeight - 10));
            
            // è½‰æ›ç‚ºé é¢çµ•å°åæ¨™
            buttonContainer.style.left = (containerRect.left + buttonX) + 'px';
            buttonContainer.style.top = (containerRect.top + buttonY) + 'px';
            
            // å‰µå»ºæ¨™é¡Œ
            const title = document.createElement('div');
            title.style.cssText = `
                font-weight: bold; 
                margin-bottom: 8px; 
                color: #333;
                font-size: 14px;
                text-align: center;
            `;
            title.textContent = `é¸ä¸­å€åŸŸ ${Math.round(selection.width)}Ã—${Math.round(selection.height)}`;
            buttonContainer.appendChild(title);
            
            // å‰µå»ºæ•¸å­¸å…¬å¼è½‰æ›æŒ‰éˆ•
            const mathButton = document.createElement('button');
            mathButton.style.cssText = `
                background: linear-gradient(135deg, #28a745, #20c997);
                color: white;
                border: none;
                padding: 10px 15px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 500;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
            `;
            mathButton.innerHTML = 'ğŸ§® æ•¸å­¸å…¬å¼è½‰æ›';
            mathButton.onmouseover = () => mathButton.style.transform = 'translateY(-1px)';
            mathButton.onmouseout = () => mathButton.style.transform = 'translateY(0)';
            mathButton.onclick = () => {
                removeSelectionButtons();
                processMathFormula({selection, imageBase64});
            };
            buttonContainer.appendChild(mathButton);
            
            // å‰µå»ºå¿ƒæ™ºåœ–ç·¨è¼¯æŒ‰éˆ•
            const mindmapButton = document.createElement('button');
            mindmapButton.style.cssText = `
                background: linear-gradient(135deg, #17a2b8, #138496);
                color: white;
                border: none;
                padding: 10px 15px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 13px;
                font-weight: 500;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
            `;
            mindmapButton.innerHTML = 'ğŸ—ºï¸ å¿ƒæ™ºåœ–ç·¨è¼¯';
            mindmapButton.onmouseover = () => mindmapButton.style.transform = 'translateY(-1px)';
            mindmapButton.onmouseout = () => mindmapButton.style.transform = 'translateY(0)';
            mindmapButton.onclick = () => {
                removeSelectionButtons();
                processMindMap({selection, imageBase64});
            };
            buttonContainer.appendChild(mindmapButton);
            
            // å‰µå»ºå–æ¶ˆæŒ‰éˆ•
            const cancelButton = document.createElement('button');
            cancelButton.style.cssText = `
                background: linear-gradient(135deg, #dc3545, #c82333);
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 12px;
                font-weight: 500;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
            `;
            cancelButton.innerHTML = 'âŒ å–æ¶ˆé¸æ“‡';
            cancelButton.onmouseover = () => cancelButton.style.transform = 'translateY(-1px)';
            cancelButton.onmouseout = () => cancelButton.style.transform = 'translateY(0)';
            cancelButton.onclick = () => {
                removeSelectionButtons();
                clearSelection();
            };
            buttonContainer.appendChild(cancelButton);
            
            // æ·»åŠ åˆ°é é¢
            document.body.appendChild(buttonContainer);
            console.log('âœ… é¸é …èœå–®å·²æ·»åŠ åˆ°é é¢');
            console.log('   ä½ç½®:', buttonX, buttonY);
            console.log('   å®¹å™¨ID:', buttonContainer.id);
            
            // æš«å­˜é¸æ“‡æ•¸æ“šä¾›å¾ŒçºŒä½¿ç”¨
            window.currentSelectionData = {
                selection: selection,
                imageBase64: imageBase64
            };
            console.log('âœ… é¸æ“‡æ•¸æ“šå·²æš«å­˜åˆ° window.currentSelectionData');
        }
        
        // ç§»é™¤é¸æ“‡æŒ‰éˆ•
        function removeSelectionButtons() {
            const existingButtons = document.getElementById('selection-buttons');
            if (existingButtons) {
                existingButtons.remove();
                console.log('Selection buttons removed');
            }
            // âš ï¸ é‡è¦ï¼šæ¸…é™¤æš«å­˜çš„é¸æ“‡æ•¸æ“šï¼Œé˜²æ­¢èª¤æ“ä½œ
            window.currentSelectionData = null;
            console.log('âœ… é¸æ“‡æ•¸æ“šå·²æ¸…é™¤');
        }
        
        // æ¸…é™¤é¸æ“‡å€åŸŸ
        function clearSelection() {
            isSelecting = false;
            isReadyToSelect = false;  // é‡ç½®æº–å‚™æ¨™å¿—
            selectionStart = {x: 0, y: 0};
            selectionEnd = {x: 0, y: 0};
            currentSelection = null;
            window.currentSelectionData = null;
            redrawCanvas();
            console.log('Selection cleared');
        }
        
        // ===== åœˆé¸åŠŸèƒ½å¯¦ç¾ =====
        function startSelection(e) {
            if (!canvas || !ctx) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // ç¢ºä¿ç¹ªåœ–æ¨¡å¼é—œé–‰ï¼Œé–‹å§‹é¸æ“‡
            isDrawing = false;
            isSelecting = true;
            selectionStart = {x: x, y: y};

            // æ›´æ–°æ¸¸æ¨™ç‚ºåœˆé¸ç‹€æ…‹
            updateCanvasCursor();
            selectionEnd = {x: x, y: y};
            
            console.log('ğŸ”² é–‹å§‹åœˆé¸:', selectionStart);
        }
        
        function updateSelection(e) {
            if (!isSelecting) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            selectionEnd = {x: x, y: y};
            redrawCanvas();
            
            // ç¹ªè£½é¸æ“‡çŸ©å½¢
            const selection = {
                x: Math.min(selectionStart.x, selectionEnd.x),
                y: Math.min(selectionStart.y, selectionEnd.y),
                width: Math.abs(selectionEnd.x - selectionStart.x),
                height: Math.abs(selectionEnd.y - selectionStart.y)
            };
            
            ctx.save();
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(selection.x, selection.y, selection.width, selection.height);
            ctx.restore();
        }
        
        function endSelection(e) {
            console.log('ğŸ” endSelection è¢«èª¿ç”¨, isSelecting:', isSelecting);
            
            if (!isSelecting) {
                console.log('âš ï¸  ä¸åœ¨åœˆé¸æ¨¡å¼ï¼Œé€€å‡º');
                return;
            }
            
            // âš ï¸ é‡è¦ï¼šæ›´æ–°æœ€çµ‚ä½ç½®ï¼ˆé˜²æ­¢ mousemove æœªè§¸ç™¼ï¼‰
            const rect = canvas.getBoundingClientRect();
            const finalX = e.clientX - rect.left;
            const finalY = e.clientY - rect.top;
            selectionEnd = {x: finalX, y: finalY};
            
            console.log('ğŸ”² åœˆé¸èµ·é»:', selectionStart);
            console.log('ğŸ”² åœˆé¸çµ‚é»:', selectionEnd);
            
            const selection = {
                x: Math.min(selectionStart.x, selectionEnd.x),
                y: Math.min(selectionStart.y, selectionEnd.y),
                width: Math.abs(selectionEnd.x - selectionStart.x),
                height: Math.abs(selectionEnd.y - selectionStart.y)
            };
            
            console.log('ğŸ”² å®Œæˆåœˆé¸:', selection);
            console.log('   å€åŸŸå°ºå¯¸:', selection.width, 'x', selection.height);
            
            if (selection.width > 10 && selection.height > 10) {
                if (isMoving) {
                    // ç§»å‹•æ¨¡å¼ï¼šé¡¯ç¤ºé¸å–æ¨¡å¼é¸æ“‡å°è©±æ¡†
                    console.log('ğŸ–ï¸ ç§»å‹•æ¨¡å¼åœˆé¸å®Œæˆï¼Œé¡¯ç¤ºæ¨¡å¼é¸æ“‡');
                    showSelectionModeDialog(selection);
                } else if (isScaling) {
                    // â­ ç¸®æ”¾æ¨¡å¼ï¼šé¡¯ç¤ºé¸å–æ¨¡å¼é¸æ“‡å°è©±æ¡†
                    console.log('ğŸ” ç¸®æ”¾æ¨¡å¼åœˆé¸å®Œæˆï¼Œé¡¯ç¤ºæ¨¡å¼é¸æ“‡');
                    showSelectionModeDialog(selection);
                } else if (isDeleting) {
                    // â­ åˆªé™¤æ¨¡å¼ï¼šé¡¯ç¤ºé¸å–æ¨¡å¼é¸æ“‡å°è©±æ¡†
                    console.log('ğŸ—‘ï¸ åˆªé™¤æ¨¡å¼åœˆé¸å®Œæˆï¼Œé¡¯ç¤ºæ¨¡å¼é¸æ“‡');
                    showSelectionModeDialog(selection);
                } else {
                    // åŸæœ‰åœˆé¸åŠŸèƒ½ï¼ˆç´”åœˆé¸æ¨¡å¼ï¼‰
                    console.log('âœ… å€åŸŸæœ‰æ•ˆï¼Œèª¿ç”¨ processSelection');
                    processSelection(selection);
                
                    // â­ åªæœ‰åœ¨ç´”åœˆé¸æ¨¡å¼ä¸‹ï¼Œæ‰è‡ªå‹•é€€å‡ºä¸¦é‡ç½®æŒ‰éˆ•
                    if (selectionOperation === 'select') {
                isReadyToSelect = false;
                        selectionOperation = null;  // é€€å‡ºåœˆé¸æ¨¡å¼
                if (selectAreaBtn) {
                            selectAreaBtn.style.background = '#95a5a6';  // æ¢å¾©ç°åº•
                }
                        console.log('âœ… ç´”åœˆé¸å®Œæˆï¼Œå·²è‡ªå‹•é€€å‡ºåœˆé¸æ¨¡å¼');
                    }
                }
            } else {
                console.log('âŒ é¸æ“‡å€åŸŸå¤ªå°ï¼Œå·²å¿½ç•¥');
                console.log('   ğŸ› èª¿è©¦ä¿¡æ¯:');
                console.log('      èµ·é» (selectionStart):', selectionStart);
                console.log('      çµ‚é» (selectionEnd):', selectionEnd);
                console.log('      è¨ˆç®—å¯¬åº¦:', Math.abs(selectionEnd.x - selectionStart.x));
                console.log('      è¨ˆç®—é«˜åº¦:', Math.abs(selectionEnd.y - selectionStart.y));
                addChatMessage('AI', `âš ï¸  **é¸æ“‡å€åŸŸå¤ªå°** (${selection.width}Ã—${selection.height} åƒç´ )\n\nè«‹åœˆé¸æ›´å¤§çš„å€åŸŸï¼ˆè‡³å°‘ 10Ã—10 åƒç´ ï¼‰ã€‚\n\nğŸ’¡ æç¤ºï¼šæŒ‰ä½é¼ æ¨™å·¦éµä¸¦**ç·©æ…¢æ‹–å‹•**åˆ°ç›®æ¨™ä½ç½®å¾Œå†æ¾é–‹ã€‚`);
            }
            
            isSelecting = false;
            redrawCanvas();
        }
        
        // è™•ç†åœˆé¸çµæœ - é¡¯ç¤ºæµ®å‹•é¸é …èœå–®
        function processSelection(selection) {
            console.log('ğŸ¯ processSelection è¢«èª¿ç”¨');
            console.log('   é¸æ“‡å€åŸŸ:', selection);
            
            // æå–é¸ä¸­å€åŸŸçš„åœ–ç‰‡æ•¸æ“š
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = selection.width;
            tempCanvas.height = selection.height;
            
            // å‰µå»ºç™½è‰²èƒŒæ™¯
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, selection.width, selection.height);
            
            // è¤‡è£½é¸ä¸­å€åŸŸ
            tempCtx.drawImage(canvas, 
                selection.x, selection.y, selection.width, selection.height,
                0, 0, selection.width, selection.height
            );
            
            const imageBase64 = tempCanvas.toDataURL('image/png');
            console.log('   åœ–ç‰‡æ•¸æ“šå·²æå–, å¤§å°:', imageBase64.length, 'å­—ç¯€');
            
            // é¡¯ç¤ºæµ®å‹•é¸é …èœå–®
            console.log('   èª¿ç”¨ showSelectionOptions...');
            showSelectionOptions(selection, imageBase64);
        }

        // æ–°å¢ï¼šå°‡åœ–ç‰‡åŠ å…¥ç•«å¸ƒä¸¦å¿«å–ï¼Œç½®ä¸­èˆ‡ç¸®æ”¾åˆ°ç•«å¸ƒ 60% å…§
        function addImageToCanvas(img) {
            if (!canvas) return;
            const maxW = Math.min(canvas.width * 0.6, 600);
            const scale = Math.min(1, maxW / img.width);
            const w = Math.round(img.width * scale);
            const h = Math.round(img.height * scale);
            const x = Math.round((canvas.width - w) / 2);
            const y = Math.round((canvas.height - h) / 2);

            const imageId = 'image_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);
            const imageObj = { id: imageId, x, y, width: w, height: h, img };

            // ä»¥æŒ‡ä»¤æ–¹å¼ç´å…¥ï¼Œæ”¯æ´æ’¤éŠ·
            if (typeof AddImageCommand === 'function') {
                historyManager.execute(new AddImageCommand(imageObj));
            } else {
                images.push(imageObj);
            }

            redrawCanvas();
            addChatMessage('AI', `ğŸ–¼ï¸ å·²ä¸Šå‚³åœ–ç‰‡ï¼š${w}Ã—${h}`);
        }
        
        function updateCanvasCursor() {
            const canvas = document.getElementById('drawing-canvas');
            if (!canvas) return;

            if (isReadyToSelect || isSelecting) {
                canvas.style.cursor = 'crosshair';
                canvas.title = 'æ‹–æ‹½é¸æ“‡å€åŸŸ';
            } else if (isMoving) {
                if (selectedItems.length > 0) {
                    canvas.style.cursor = 'move';
                    canvas.title = 'æ‹–æ‹½ç§»å‹•é¸ä¸­å…§å®¹';
                } else {
                    canvas.style.cursor = 'crosshair';
                    canvas.title = 'åœˆé¸è¦ç§»å‹•çš„å…§å®¹';
                }
            } else {
                canvas.style.cursor = 'crosshair';
                canvas.title = 'é»æ“Šæ‹–æ‹½ç¹ªç•«ï¼›ä½¿ç”¨å·¦å´æŒ‰éˆ•é€²å…¥åœˆé¸/ç§»å‹•/ç¸®æ”¾æ¨¡å¼';
            }
        }
        
        // ===== çµ±ä¸€ç•«å¸ƒäº‹ä»¶è™•ç† =====
        function handleCanvasMouseDown(e) {
            console.log('ğŸ–±ï¸  mousedown, selectionOperation:', selectionOperation, ', isSelecting:', isSelecting, ', isReadyToSelect:', isReadyToSelect, ', isMoving:', isMoving, ', selectedItems:', selectedItems.length);

            // â­ å„ªå…ˆç´šé †åºï¼šæŒ‰éˆ•æ¨¡å¼ > ç¹ªåœ–æ¨¡å¼
            
            // 1. åœˆé¸æ¨¡å¼ï¼ˆé»æ“Šã€Œé¸ã€æŒ‰éˆ•å¾Œï¼‰
            if (isReadyToSelect) {
                console.log('ğŸ”² å•Ÿå‹•åœˆé¸');
                isReadyToSelect = false;  // æ¸…é™¤æº–å‚™æ¨™å¿—
                startSelection(e);
            } 
            // 2. å·²ç¶“åœ¨åœˆé¸ä¸­
            else if (isSelecting) {
                console.log('ğŸ”² ç¹¼çºŒåœˆé¸');
                startSelection(e);
            } 
            // 3. ç§»å‹•æ¨¡å¼ï¼ˆé»æ“Šã€Œç§»å‹•ã€æŒ‰éˆ•å¾Œï¼‰
            else if (isMoving) {
                if (selectedItems.length > 0) {
                    // æœ‰é¸ä¸­é …ç›®ï¼šé–‹å§‹æ‹–æ‹½
                    console.log('ğŸ–ï¸ é–‹å§‹ç§»å‹•æ‹–æ‹½å·²é¸ä¸­çš„å…§å®¹');
                    isDragging = true;
                    const rect = canvas.getBoundingClientRect();
                    moveStartPoint = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                } else {
                    // æ²’æœ‰é¸ä¸­é …ç›®ï¼šé–‹å§‹åœˆé¸
                    console.log('ğŸ”² ç§»å‹•æ¨¡å¼ï¼šå•Ÿå‹•åœˆé¸ä¾†é¸æ“‡è¦ç§»å‹•çš„å…§å®¹');
                    startSelection(e);
                }
            }
            // 4. ç¸®æ”¾æ¨¡å¼ï¼ˆé»æ“Šã€Œç¸®æ”¾ã€æŒ‰éˆ•å¾Œï¼‰
            else if (isScaling) {
                if (selectedItems.length > 0 && scalingBounds) {
                    // æœ‰é¸ä¸­é …ç›®ï¼šæª¢æŸ¥æ˜¯å¦é»æ“Šè§’è½
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const corner = getCornerAtPoint(x, y);
                    if (corner) {
                        // é»æ“Šäº†è§’è½ï¼šé–‹å§‹æ‹–æ‹½ç¸®æ”¾
                        console.log('ğŸ” é–‹å§‹æ‹–æ‹½ç¸®æ”¾ï¼Œè§’è½:', corner);
                        scalingCorner = corner;
                        scalingStartPoint = {x, y};
                        scalingInitialBounds = {...scalingBounds};
            } else {
                        console.log('âš ï¸ è«‹é»æ“Šé‚Šç•Œæ¡†çš„è§’è½ä¾†ç¸®æ”¾');
                        addChatMessage('AI', 'âš ï¸ è«‹é»æ“Šé‚Šç•Œæ¡†çš„**è—è‰²æ–¹å¡Š**ï¼ˆè§’è½ï¼‰ä¾†ç¸®æ”¾');
                    }
                } else {
                    // æ²’æœ‰é¸ä¸­é …ç›®ï¼šé–‹å§‹åœˆé¸
                    console.log('ğŸ”² ç¸®æ”¾æ¨¡å¼ï¼šå•Ÿå‹•åœˆé¸ä¾†é¸æ“‡è¦ç¸®æ”¾çš„å…§å®¹');
                    startSelection(e);
                }
            }
            // 5. åˆªé™¤æ¨¡å¼ï¼ˆé»æ“Šã€Œåˆªé™¤ã€æŒ‰éˆ•å¾Œï¼‰
            else if (isDeleting) {
                console.log('ğŸ—‘ï¸ åˆªé™¤æ¨¡å¼ï¼ˆæœªå¯¦ä½œï¼‰');
                addChatMessage('AI', 'âš ï¸ åˆªé™¤åŠŸèƒ½æ­£åœ¨é–‹ç™¼ä¸­...');
            }
            // 6. é è¨­ç¹ªåœ–æ¨¡å¼ï¼ˆæ²’æœ‰ä»»ä½•æŒ‰éˆ•è¢«æ¿€æ´»ï¼‰
            else {
                console.log('âœï¸  å•Ÿå‹•ç¹ªåœ–');
                startDrawing(e);
            }
        }
        
        function handleCanvasMouseMove(e) {
            // â­ å„ªå…ˆç´šé †åºï¼šç¢ºä¿åªæœ‰ä¸€å€‹ç‹€æ…‹è™•ç†ç§»å‹•äº‹ä»¶
            
            // 1. ç¹ªåœ–ä¸­
            if (isDrawing) {
                draw(e);
            } 
            // 2. åœˆé¸ä¸­
            else if (isSelecting) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                console.log('ğŸ”„ mousemove (åœˆé¸ä¸­):', Math.round(x), ',', Math.round(y));
                updateSelection(e);
            } 
            // 3. æ‹–æ‹½ç§»å‹•ä¸­
            else if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                const deltaX = currentX - moveStartPoint.x;
                const deltaY = currentY - moveStartPoint.y;
                
                console.log('ğŸ”„ ç§»å‹•æ‹–æ‹½: Î”x=' + deltaX.toFixed(1) + ', Î”y=' + deltaY.toFixed(1));
                
                // â­ ç´¯ç©ç§»å‹•å¢é‡ï¼ˆç”¨æ–¼ç¨å¾Œå‰µå»º Commandï¼‰
                if (!tempMoveDeltas) {
                    tempMoveDeltas = {totalX: 0, totalY: 0};
                }
                tempMoveDeltas.totalX += deltaX;
                tempMoveDeltas.totalY += deltaY;
                
                // ç§»å‹•æ‰€æœ‰é¸ä¸­é …ç›®ï¼ˆè¦–è¦ºåé¥‹ï¼‰
                moveSelectedItems(deltaX, deltaY);
                
                // æ›´æ–°èµ·å§‹é»ç‚ºç•¶å‰ä½ç½®
                moveStartPoint.x = currentX;
                moveStartPoint.y = currentY;
            }
            // 4. â­ æ‹–æ‹½ç¸®æ”¾ä¸­
            else if (scalingCorner) {
                const rect = canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
                const ratio = calculateScaleRatio(scalingCorner, currentX, currentY);
                
                console.log('ğŸ” ç¸®æ”¾ä¸­ï¼Œæ¯”ä¾‹:', ratio.toFixed(2));
                
                // æ‡‰ç”¨ç¸®æ”¾
                applyScale(ratio);
                // è¨˜éŒ„æœ€å¾Œç¸®æ”¾æ¯”ä¾‹ï¼Œä¾› mouseup å¯«å…¥æ­·å²
                lastScalingRatio = ratio;
            } else {
                // éæ‹–æ‹½ç¸®æ”¾æ™‚ï¼Œå¦‚æœåœ¨ç¸®æ”¾æ¨¡å¼ä¸”å­˜åœ¨é‚Šç•Œæ¡†ï¼Œæä¾›æ¸¸æ¨™æç¤º
                if (isScaling && scalingBounds) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const corner = getCornerAtPoint(x, y);
                    canvas.style.cursor = corner ? 'se-resize' : 'crosshair';
                }
            }
        }
        
        function handleCanvasMouseUp(e) {
            console.log('ğŸ–±ï¸  mouseup, isDrawing:', isDrawing, ', isSelecting:', isSelecting, ', isReadyToSelect:', isReadyToSelect);
            
            if (isDrawing) {
                console.log('âœï¸  åœæ­¢ç¹ªåœ–');
                stopDrawing(e);
            } else if (isSelecting) {
                console.log('ğŸ”² çµæŸåœˆé¸');
                endSelection(e);
            } else if (isDragging) {
                // ç§»å‹•æ¨¡å¼ï¼šçµæŸæ‹–æ‹½
                console.log('ğŸ–ï¸ çµæŸç§»å‹•æ‹–æ‹½');
                isDragging = false;
                
                // â­ æäº¤ç§»å‹•æŒ‡ä»¤åˆ°æ­·å²è¨˜éŒ„
                if (tempMoveDeltas && (tempMoveDeltas.totalX !== 0 || tempMoveDeltas.totalY !== 0)) {
                    const command = new MoveItemsCommand(
                        selectedItems,
                        tempMoveDeltas.totalX,
                        tempMoveDeltas.totalY
                    );
                    historyManager.execute(command);
                    tempMoveDeltas = null;
                }
                
                addChatMessage('AI', 'âœ… **ç§»å‹•å®Œæˆ**');
                updateCanvasCursor(); // æ›´æ–°æ¸¸æ¨™ç‹€æ…‹
            } else if (scalingCorner) {
                // â­ ç¸®æ”¾æ¨¡å¼ï¼šçµæŸæ‹–æ‹½ç¸®æ”¾
                console.log('ğŸ” çµæŸæ‹–æ‹½ç¸®æ”¾');
                
                // â­ æäº¤ç¸®æ”¾æŒ‡ä»¤åˆ°æ­·å²è¨˜éŒ„ï¼ˆä½¿ç”¨æœ€å¾Œä¸€æ¬¡ç¸®æ”¾æ¯”ä¾‹ï¼‰
                if (scalingInitialBounds && scalingInitialItems) {
                    const ratio = lastScalingRatio || 1.0;
                    const command = new ScaleItemsCommand(
                        selectedItems,
                        scalingInitialBounds.centerX,
                        scalingInitialBounds.centerY,
                        ratio
                    );
                    historyManager.execute(command);
                }
                
                // â­ å®Œå…¨æ¸…é™¤æ‰€æœ‰ç¸®æ”¾ç›¸é—œç‹€æ…‹
                scalingCorner = null;
                scalingStartPoint = {x: 0, y: 0};
                scalingInitialBounds = null;
                scalingInitialItems = null;
                scalingBounds = null; // â­ æ¸…é™¤é‚Šç•Œæ¡†
                
                // â­ æ¸…é™¤é¸ä¸­é …ç›®ï¼Œé€€å‡ºç¸®æ”¾æ¨¡å¼
                selectedItems = [];
                isScaling = false; // â­ é‡è¦ï¼šé€€å‡ºç¸®æ”¾æ¨¡å¼
                selectionOperation = null; // â­ æ¸…é™¤æ“ä½œæ¨¡å¼
                
                // â­ é‡ç½®ç¸®æ”¾æŒ‰éˆ•æ¨£å¼
                if (scaleBtn) scaleBtn.style.background = '#95a5a6';
                
                addChatMessage('AI', 'âœ… **ç¸®æ”¾å®Œæˆ**\n\nå·²å›åˆ°ç¹ªåœ–æ¨¡å¼ï¼Œå¯ä»¥ç¹¼çºŒç¹ªç•«ã€‚');
                
                // é‡ç¹ªç•«å¸ƒï¼ˆç§»é™¤é‚Šç•Œæ¡†ï¼‰
                redrawCanvas();
                updateCanvasCursor(); // â­ æ›´æ–°æ¸¸æ¨™
            } else if (isReadyToSelect) {
                // å¦‚æœæº–å‚™åœˆé¸ä½†æ²’æœ‰çœŸæ­£é–‹å§‹ï¼ˆä¾‹å¦‚åªæ˜¯ç§»å‹•é¼ æ¨™ï¼‰ï¼Œå–æ¶ˆæº–å‚™ç‹€æ…‹
                console.log('âš ï¸  å–æ¶ˆåœˆé¸æº–å‚™ï¼ˆæœªé–‹å§‹åœˆé¸å°± mouseupï¼‰');
                isReadyToSelect = false;
            } else {
                console.log('âš ï¸  æ—¢ä¸åœ¨ç¹ªåœ–ä¹Ÿä¸åœ¨åœˆé¸ç‹€æ…‹');
            }
        }
        
        function handleCanvasMouseOut(e) {
            if (isDrawing) {
                stopDrawing(e);
            }
        }
        

        
        // è™•ç†æ•¸å­¸å…¬å¼è½‰æ›
        async function processMathFormula(selectionData) {
            // âš ï¸ å®‰å…¨æª¢æŸ¥ï¼šç¢ºä¿ selectionData å­˜åœ¨ä¸”æœ‰æ•ˆ
            if (!selectionData || !selectionData.imageBase64) {
                console.error('âŒ processMathFormula: selectionData ç„¡æ•ˆæˆ–ç‚ºç©º');
                addChatMessage('AI', 'âŒ **è™•ç†å¤±æ•—**\n\né¸æ“‡æ•¸æ“šç„¡æ•ˆï¼Œè«‹é‡æ–°åœˆé¸ã€‚');
                return;
            }
            
            addChatMessage('AI', 'ğŸ§® æ­£åœ¨åˆ†ææ•¸å­¸å…¬å¼...');
            
            try {
                // èª¿ç”¨å°ˆé–€çš„æ•¸å­¸å…¬å¼åˆ†æAPI
                const headers = {
                    'Content-Type': 'application/json',
                    ...AIConfig.getHeaders()
                };
                
                console.log('ğŸ“¤ ç™¼é€æ•¸å­¸å…¬å¼åˆ†æè«‹æ±‚ï¼ŒHeaders:', headers);
                
                const response = await fetch('/api/analyze-math', {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        image_data: selectionData.imageBase64
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.latex) {
                    console.log('âœ… AIè¿”å›LaTeX:', result.latex);
                    
                    // å…ˆæ¸…ç†LaTeXæ ¼å¼ä»¥ä¾›é¡¯ç¤º
                    let displayLatex = sanitizeLatex(result.latex);
                    
                    // âš ï¸ æª¢æŸ¥æ¸…ç†å¾Œçš„LaTeXæ˜¯å¦ç‚ºç©ºï¼ˆé¿å…èª¤åˆªç•«å¸ƒå…§å®¹ï¼‰
                    if (!displayLatex || displayLatex.length === 0) {
                        console.error('âŒ AIè¿”å›ç©ºLaTeXï¼Œæ‹’çµ•è™•ç†');
                        addChatMessage('AI', 'âŒ **è­˜åˆ¥å¤±æ•—**\n\nç„¡æ³•è­˜åˆ¥åœˆé¸å€åŸŸçš„æ•¸å­¸å…¬å¼ã€‚\nå¯èƒ½åŸå› ï¼š\nâ€¢ åœˆé¸äº†å·²ç¶“è½‰æ›éçš„å…¬å¼ï¼ˆè«‹åœˆé¸æ‰‹å¯«å…§å®¹ï¼‰\nâ€¢ AIè­˜åˆ¥å¤±æ•—\nâ€¢ åœ–ç‰‡ä¸æ¸…æ™°');
                        isSelecting = false;
                        isReadyToSelect = false;
                        return;
                    }
                    
                    addChatMessage('AI', `ğŸ§® **è­˜åˆ¥æˆåŠŸï¼**\n\nğŸ“ LaTeX: \`${displayLatex}\`\nğŸ¯ ä¿¡å¿ƒåº¦: ${Math.round((result.confidence || 0) * 100)}%`);
                    
                    console.log('ğŸ¨ é–‹å§‹æ¸²æŸ“å…¬å¼...');
                    // ä½¿ç”¨KaTeXæ¸²æŸ“å…¬å¼
                    renderMathFormula(result.latex, selectionData.selection);
                } else if (result.success && result.analysis) {
                    // å¦‚æœæ²’æœ‰LaTeXä½†æœ‰åˆ†æçµæœï¼Œå˜—è©¦æå–
                    const latexRaw = extractLatexFromResponse(result.analysis);
                    const latex = latexRaw ? sanitizeLatex(latexRaw) : null;
                    
                    if (latex) {
                        addChatMessage('AI', `ğŸ§® **åˆ†æçµæœï¼š**\n${result.analysis}\n\nğŸ“ æå–çš„LaTeX: \`${latex}\``);
                        renderMathFormula(latex, selectionData.selection);
                    } else {
                        addChatMessage('AI', `ğŸ“ **åˆ†æçµæœï¼š**\n${result.analysis}\n\nâš ï¸ æœªèƒ½è­˜åˆ¥å‡ºæ¨™æº–æ•¸å­¸å…¬å¼æ ¼å¼ã€‚`);
                    }
                } else {
                    addChatMessage('AI', `âŒ å…¬å¼åˆ†æå¤±æ•—ï¼š${result.error || 'è«‹ç¢ºä¿é¸ä¸­å€åŸŸåŒ…å«æ¸…æ™°çš„æ•¸å­¸å…¬å¼ã€‚'}`);
                }
            } catch (error) {
                console.error('Math formula processing error:', error);
                addChatMessage('AI', 'âŒ é€£æ¥åˆ†ææœå‹™å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚');
            }
            
            // æ¸…é™¤é¸æ“‡æ•¸æ“š
            window.currentSelectionData = null;
        }
        
        // å¾AIå›æ‡‰ä¸­æå–LaTeXå…¬å¼
        function extractLatexFromResponse(response) {
            console.log('ğŸ” æå– LaTeXï¼ŒåŸå§‹å›æ‡‰:', response);
            
            // å°‹æ‰¾LaTeXæ ¼å¼çš„å…¬å¼ï¼ˆå¤šç¨®æ ¼å¼ï¼‰
            const latexPatterns = [
                /\\\[([^\]]+)\\\]/g,     // \[...\]
                /\\\(([^\)]+)\\\)/g,     // \(...\)
                /\$\$([^$]+)\$\$/g,      // $$...$$
                /\$([^$]+)\$/g,          // $...$
                /\\begin\{[^}]+\}.*?\\end\{[^}]+\}/gs,  // \begin{...}...\end{...}
            ];
            
            for (const pattern of latexPatterns) {
                const matches = response.match(pattern);
                if (matches && matches.length > 0) {
                    console.log('âœ… æ‰¾åˆ° LaTeX æ ¼å¼:', matches[0]);
                    return matches[0];
                }
            }
            
            // å¦‚æœæ²’æœ‰æ‰¾åˆ°æ¨™æº–LaTeXæ ¼å¼ï¼Œå˜—è©¦æå–å¯èƒ½çš„æ•¸å­¸è¡¨é”å¼
            const mathKeywords = ['equation', 'formula', 'expression', 'å…¬å¼', 'æ–¹ç¨‹', 'int', 'frac', 'sum'];
            if (mathKeywords.some(keyword => response.toLowerCase().includes(keyword))) {
                console.log('âš ï¸ ä½¿ç”¨å‚™ç”¨æå–é‚è¼¯');
                // è¿”å›æ•´å€‹å›æ‡‰ï¼ˆç¨å¾Œå†æ¸…ç†ï¼‰
                return response.trim();
            }
            
            console.log('âŒ æœªæ‰¾åˆ° LaTeX æ ¼å¼');
            return null;
        }
        
        // å…±äº«ï¼šLaTeX æ¸…ç†å™¨ï¼ˆå¼·åŒ–ç‰ˆï¼‰
        function sanitizeLatex(input) {
            if (!input) return '';
            let s = ('' + input)
                .replace(/^\s+|\s+$/g, '')
                // å»é™¤åŒ…è£¹ç¬¦è™Ÿèˆ‡ä»£ç¢¼æ¡†
                .replace(/^```[\s\S]*?```$/g, function(m){ return m.replace(/^```|```$/g, ''); })
                .replace(/^\\\[/, '').replace(/\\\]$/, '')
                .replace(/^\\\(/, '').replace(/\\\)$/, '')
                .replace(/^\$\$/, '').replace(/\$\$$/, '')
                .replace(/^\$/, '').replace(/\$$/, '')
                // ç§»é™¤å‰ç¶´æ–‡å­—
                .replace(/^.*?[:ï¼š]\s*/, '')
                .replace(/^(åˆ†æçµæœ|å…¬å¼|equation|formula|Expression)\s*/i, '')
                // ç§»é™¤æœ«å°¾å­¤ç«‹é‹ç®—å­èˆ‡å¤šé¤˜ç©ºç™½
                .replace(/[=+\-*/]\s*$/,'')
                .replace(/\s+/g, ' ')
                .trim();
            // é‡å°å¸¸è¦‹ AI å¤šé¤˜ç¬¦è™Ÿ
            s = s.replace(/[ã€‚ï¼Œã€ï¼ã€‚]+$/,'');
            return s;
        }

        // æ¸²æŸ“æ•¸å­¸å…¬å¼ä¸¦æ›¿æ›åˆ°ç•«å¸ƒ - å®Œå…¨é‡å¯«ç‰ˆæœ¬
        function renderMathFormula(latex, selection) {
            console.log('ğŸ¯ renderMathFormula é–‹å§‹åŸ·è¡Œ');
            console.log('   è¼¸å…¥LaTeX:', latex);
            console.log('   é¸æ“‡å€åŸŸ:', selection);
            
            // â­ æ­¥é©Ÿ1: å¢å¼·ç‰ˆ LaTeX æ¸…ç†é‚è¼¯
            let cleanLatex = sanitizeLatex(latex);
            
            console.log('   æ¸…ç†å¾ŒLaTeX:', cleanLatex);
            console.log('   LaTeX é•·åº¦:', cleanLatex.length);
            
            // æª¢æŸ¥æ¸…ç†å¾Œçš„LaTeXæ˜¯å¦ç‚ºç©ºæˆ–éçŸ­
            if (!cleanLatex || cleanLatex.length === 0) {
                console.error('âŒ LaTeXå…§å®¹ç‚ºç©ºï¼Œç„¡æ³•æ¸²æŸ“');
                addChatMessage('AI', 'âŒ **è­˜åˆ¥å¤±æ•—**\n\nç„¡æ³•è­˜åˆ¥åœˆé¸å€åŸŸçš„æ•¸å­¸å…¬å¼ã€‚\nå¯èƒ½åŸå› ï¼š\nâ€¢ åœˆé¸äº†å·²ç¶“è½‰æ›éçš„å…¬å¼\nâ€¢ AIè­˜åˆ¥å¤±æ•—\nâ€¢ åœ–ç‰‡ä¸æ¸…æ™°\n\nåŸå§‹å›æ‡‰: ' + latex.substring(0, 50));
                isSelecting = false;
                isReadyToSelect = false;
                return;
            }
            
            // æª¢æŸ¥æ˜¯å¦åªæ˜¯ç¬¦è™Ÿæ²’æœ‰å¯¦éš›å…§å®¹
            if (cleanLatex.length < 2 || /^[=+\-*/\s]+$/.test(cleanLatex)) {
                console.error('âŒ LaTeXåªåŒ…å«ç¬¦è™Ÿï¼Œæ²’æœ‰å¯¦éš›å…§å®¹');
                addChatMessage('AI', 'âŒ **è­˜åˆ¥å¤±æ•—**\n\næå–çš„å…¬å¼åªåŒ…å«ç¬¦è™Ÿï¼Œæ²’æœ‰å¯¦éš›å…§å®¹ã€‚\n\næå–å…§å®¹: "' + cleanLatex + '"');
                isSelecting = false;
                isReadyToSelect = false;
                return;
            }
            
            // æ­¥é©Ÿ2: ä½¿ç”¨KaTeXæ¸²æŸ“LaTeXç‚ºHTML
            // âš ï¸ æ–°è¦å‰‡ï¼šå®¹å™¨å¤§å° = åœˆé¸å¤§å°ï¼ˆä¿è­‰å®Œå…¨è¦†è“‹ï¼‰
            const container = document.createElement('div');
            container.style.cssText = `
                position: absolute;
                left: -9999px;
                width: ${selection.width}px;
                height: ${selection.height}px;
                display: flex;
                align-items: center;
                justify-content: center;
                background: white;
                padding: 0;
                box-sizing: border-box;
                overflow: hidden;
            `;
            document.body.appendChild(container);
            
            console.log('ğŸ“ æ¸²æŸ“è¨­å®š: å®¹å™¨å¤§å° =', selection.width, 'x', selection.height, 'px (å›ºå®š)');
            
            try {
                katex.render(cleanLatex, container, { throwOnError: false, displayMode: true });
                console.log('âœ… KaTeXæ¸²æŸ“æˆåŠŸ');
                
                // æ­¥é©Ÿ3: ä½¿ç”¨html2canvaså°‡HTMLè½‰ç‚ºåœ–ç‰‡ï¼ˆå›ºå®šå°ºå¯¸ï¼‰
                html2canvas(container, { 
                    backgroundColor: 'white', 
                    scale: 2,
                    width: selection.width,
                    height: selection.height
                }).then(canvas2 => {
                    document.body.removeChild(container);
                    
                    const img = new Image();
                    img.onload = () => {
                        console.log('âœ… åœ–ç‰‡è¼‰å…¥æˆåŠŸï¼Œå°ºå¯¸:', img.width, 'x', img.height);
                        
                        // â­ æ­¥é©Ÿ4: ä½¿ç”¨å¯¦éš›æ¸²æŸ“å¾Œçš„åœ–ç‰‡å¤§å°ï¼ˆè€Œéåœˆé¸å€åŸŸå¤§å°ï¼‰
                        // ä½ç½®è¨ˆç®—ï¼šå°‡å…¬å¼åœ–ç‰‡çš„ä¸­å¿ƒé»å°é½Šåˆ°åœˆé¸å€åŸŸçš„ä¸­å¿ƒé»
                        // å¤§å°ï¼šä½¿ç”¨å¯¦éš› canvas è¿”å›çš„åœ–ç‰‡å¤§å°ï¼ˆçœŸå¯¦å…¬å¼å¤§å°ï¼‰
                        
                        // è¨ˆç®—åœˆé¸å€åŸŸçš„ä¸­å¿ƒé»
                        const selectionCenterX = selection.x + selection.width / 2;
                        const selectionCenterY = selection.y + selection.height / 2;
                        
                        // ä½¿ç”¨å¯¦éš›åœ–ç‰‡å¤§å°
                        const w = img.width;   // â­ ä½¿ç”¨å¯¦éš›åœ–ç‰‡å¯¬åº¦
                        const h = img.height;  // â­ ä½¿ç”¨å¯¦éš›åœ–ç‰‡é«˜åº¦
                        
                        // å°‡å…¬å¼åœ–ç‰‡çš„ä¸­å¿ƒé»å°é½Šåˆ°åœˆé¸å€åŸŸçš„ä¸­å¿ƒé»
                        const x = selectionCenterX - w / 2;
                        const y = selectionCenterY - h / 2;
                        
                        console.log('ğŸ“ ç¹ªè£½åƒæ•¸:');
                        console.log('   åœˆé¸ç¯„åœ:', selection);
                        console.log('   åœˆé¸ä¸­å¿ƒé»:', {x: selectionCenterX, y: selectionCenterY});
                        console.log('   æ¸²æŸ“åœ–ç‰‡ï¼ˆå¯¦éš›å¤§å°ï¼‰:', {width: img.width, height: img.height});
                        console.log('   æœ€çµ‚ä½ç½®ï¼ˆç½®ä¸­å°é½Šï¼‰:', {x, y, w, h});
                        console.log('   â­ å…¬å¼åœ–ç‰‡ä¸­å¿ƒ = åœˆé¸å€åŸŸä¸­å¿ƒ');
                        
                        // æ­¥é©Ÿ5: å…ˆå¾strokesä¸­ç§»é™¤é¸æ“‡å€åŸŸå…§çš„ç­†ç•«
                        // âš ï¸ æ–°è¦å‰‡ï¼šåªåˆªé™¤ã€Œæœ‰é‡ç–Šã€çš„å…§å®¹ï¼Œä¸ç®¡æ©¡çš®æ“¦
                        const newStrokes = [];
                        
                        // è¼”åŠ©å‡½æ•¸ï¼šè¨ˆç®—å…©å€‹çŸ©å½¢çš„é‡ç–Šé¢ç©ç™¾åˆ†æ¯”
                        function getOverlapRatio(rect1, rect2) {
                            const x_overlap = Math.max(0, Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - Math.max(rect1.x, rect2.x));
                            const y_overlap = Math.max(0, Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - Math.max(rect1.y, rect2.y));
                            const overlapArea = x_overlap * y_overlap;
                            const rect1Area = rect1.width * rect1.height;
                            return rect1Area > 0 ? (overlapArea / rect1Area) : 0;
                        }
                        
                        for (let i = 0; i < strokes.length; i++) {
                            const stroke = strokes[i];
                            let keepStroke = true;
                            
                            if (stroke.tool === 'image') {
                                // åœ–ç‰‡ç­†ç•«ï¼šä½¿ç”¨å¯¦éš›ç¹ªè£½å€åŸŸï¼ˆä¸ä½¿ç”¨åŸåœˆé¸å€ï¼‰
                                // åªè¦ã€Œå¯¦éš›å…¬å¼åœ–ç‰‡ã€æœ‰ 50% ä»¥ä¸Šåœ¨é¸å€å…§ï¼Œå°±åˆªé™¤
                                const imageArea = {
                                    x: stroke.x,
                                    y: stroke.y,
                                    width: stroke.width,
                                    height: stroke.height
                                };
                                
                                const overlapRatio = getOverlapRatio(imageArea, selection);
                                
                                if (overlapRatio > 0.5) {
                                    keepStroke = false;
                                    console.log('ğŸ—‘ï¸  ç§»é™¤é‡ç–Šçš„å…¬å¼:', stroke.id || 'unknown');
                                    console.log('   å…¬å¼ä½ç½®:', `${Math.round(imageArea.x)},${Math.round(imageArea.y)} ${Math.round(imageArea.width)}x${Math.round(imageArea.height)}`);
                                    console.log('   æ–°é¸å€:', `${Math.round(selection.x)},${Math.round(selection.y)} ${Math.round(selection.width)}x${Math.round(selection.height)}`);
                                    console.log('   é‡ç–Šæ¯”ä¾‹:', (overlapRatio * 100).toFixed(1) + '%');
                                } else {
                                    console.log('âœ… ä¿ç•™å…¬å¼:', stroke.id || 'unknown', `(é‡ç–Š ${(overlapRatio * 100).toFixed(1)}% < 50%)`);
                                }
                            } else if (stroke.points) {
                                // æ™®é€šç­†ç•«ï¼šä½¿ç”¨ 50% é–€æª»ï¼ˆèˆ‡åœ–ç‰‡ç­†ç•«ä¸€è‡´ï¼‰
                                const pointsInSelection = stroke.points.filter(p => 
                                    p.x >= selection.x && p.x <= selection.x + selection.width &&
                                    p.y >= selection.y && p.y <= selection.y + selection.height
                                ).length;
                                
                                const overlapRatio = pointsInSelection / stroke.points.length;
                                
                                if (overlapRatio > 0.5) {  // â† 50% ä»¥ä¸Šå°±åˆªé™¤
                                    keepStroke = false;
                                    console.log('ğŸ—‘ï¸  ç§»é™¤é‡ç–Šçš„ç­†ç•«:', Math.round(overlapRatio * 100) + '% (', pointsInSelection, '/', stroke.points.length, ')');
                                } else if (pointsInSelection > 0) {
                                    console.log('âœ… ä¿ç•™ç­†ç•«:', Math.round(overlapRatio * 100) + '% < 50% (', pointsInSelection, '/', stroke.points.length, ')');
                                }
                            }
                            
                            if (keepStroke) {
                                newStrokes.push(stroke);
                            }
                        }
                        
                        // æ›´æ–°strokesæ•¸çµ„
                        strokes.length = 0;
                        strokes.push(...newStrokes);
                        
                        console.log('ğŸ—‘ï¸  å·²ç§»é™¤é¸æ“‡å€åŸŸå…§çš„ç­†ç•«ï¼Œå‰©é¤˜:', strokes.length);
                        
                        // æ­¥é©Ÿ6: æ·»åŠ å…¬å¼åœ–ç‰‡ä½œç‚ºæ–°ç­†ç•«ï¼ˆå¸¶å”¯ä¸€IDå’ŒåŸå§‹è³‡æ–™ï¼‰
                        const formulaId = 'formula_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        const formulaStroke = {
                            tool: 'image',
                            image: img,
                            x: x,
                            y: y,
                            width: w,
                            height: h,
                            // æ·»åŠ å…¬å¼ç‰¹æœ‰å±¬æ€§
                            id: formulaId,
                            type: 'math_formula',
                            originalLatex: cleanLatex,
                            selectionArea: {
                                x: selection.x,
                                y: selection.y,
                                width: selection.width,
                                height: selection.height
                            },
                            timestamp: Date.now(),
                            editable: true  // æ¨™è¨˜ç‚ºå¯ç¨ç«‹ç·¨è¼¯
                        };
                        
                        // â­ æ”¹ç”¨ Command Pattern
                        const command = new AddFormulaCommand(formulaStroke, formulaId);
                        historyManager.execute(command);
                        
                        console.log('âœ… å…¬å¼å·²æ·»åŠ ç‚ºå¯ç·¨è¼¯ç­†ç•«:', formulaId);
                        console.log('ğŸ“‹ ç•¶å‰å…¬å¼æ•¸é‡:', formulaObjects.size);
                        console.log('âœ… å…¬å¼å·²æ·»åŠ ç‚ºç­†ç•«ï¼Œç¸½æ•¸:', strokes.length);
                        
                        // æ­¥é©Ÿ7: é‡ç¹ªæ•´å€‹ç•«å¸ƒ
                        redrawCanvas();
                        console.log('âœ… ç•«å¸ƒå·²é‡ç¹ª');
                        
                        // æ­¥é©Ÿ8: æ¸…é™¤é¸æ“‡ç‹€æ…‹
                        isSelecting = false;
                        isReadyToSelect = false;
                        selectionStart = {x: 0, y: 0};
                        selectionEnd = {x: 0, y: 0};
                        currentSelection = null;
                        window.currentSelectionData = null;
                        
                        // æ­¥é©Ÿ9: é¡¯ç¤ºæˆåŠŸè¨Šæ¯
                        addChatMessage('AI', `âœ… **æ•¸å­¸å…¬å¼è½‰æ›å®Œæˆï¼**\n\nğŸ“ LaTeX: \`${cleanLatex}\`\nğŸ¨ å·²æ›¿æ›åˆ°ç•«å¸ƒä¸Š`);
                        console.log('ğŸ‰ renderMathFormula å®Œæˆï¼');
                    };
                    img.src = canvas2.toDataURL();
                }).catch(err => {
                    document.body.removeChild(container);
                    console.error('âŒ html2canvaséŒ¯èª¤:', err);
                    addChatMessage('AI', 'âŒ æ¸²æŸ“å¤±æ•—');
                });
                
            } catch (err) {
                document.body.removeChild(container);
                console.error('âŒ KaTeXéŒ¯èª¤:', err);
                addChatMessage('AI', `âŒ LaTeXèªæ³•éŒ¯èª¤: ${err.message}`);
            }
        }
        
        // è™•ç†å¿ƒæ™ºåœ–åŠŸèƒ½ï¼ˆæš«æ™‚ç°¡åŒ–å¯¦ç¾ï¼‰
        function processMindMap(selectionData) {
            addChatMessage('AI', 'ğŸ—ºï¸ å¿ƒæ™ºåœ–åŠŸèƒ½æ­£åœ¨é–‹ç™¼ä¸­...\n\nç•¶å‰é¸ä¸­å€åŸŸå°‡åœ¨æœªä¾†ç‰ˆæœ¬ä¸­æ”¯æŒè½‰æ›ç‚ºå¯ç·¨è¼¯çš„å¿ƒæ™ºåœ–ã€‚');
            // æ¸…é™¤é¸æ“‡æ•¸æ“š
            window.currentSelectionData = null;
        }
        
        // ===== å…¨å±€è®Šé‡è²æ˜ =====
        let canvas = null;
        let ctx = null;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentTool = 'pen';
        let currentColor = '#2c3e50';
        let currentSize = 5;
        let strokes = []; // è¨˜éŒ„æ‰€æœ‰ç­†ç•«æ•¸æ“š
        let currentStroke = null; // ç•¶å‰æ­£åœ¨ç¹ªè£½çš„ç­†ç•«
        let images = []; // è¨˜éŒ„æ‰€æœ‰æ’å…¥çš„åœ–ç‰‡æ•¸æ“š
        
        // å…¬å¼ç®¡ç†ç³»çµ±
        let formulaObjects = new Map(); // å­˜å„²æ‰€æœ‰æ¸²æŸ“çš„å…¬å¼å°è±¡ {id: {stroke, metadata}}
        let layerOrder = []; // è¨˜éŒ„æ‰€æœ‰å°è±¡çš„å±¤æ¬¡é †åº
        
        // å…¬å¼ç®¡ç†å‡½æ•¸
        function getFormulaAtPoint(x, y) {
            // å¾æœ€ä¸Šå±¤é–‹å§‹æª¢æŸ¥ï¼ˆæœ€å¾Œæ·»åŠ çš„å„ªå…ˆï¼‰
            for (let i = layerOrder.length - 1; i >= 0; i--) {
                const formulaId = layerOrder[i];
                const formulaObj = formulaObjects.get(formulaId);
                if (formulaObj && formulaObj.stroke) {
                    const stroke = formulaObj.stroke;
                    if (x >= stroke.x && x <= stroke.x + stroke.width &&
                        y >= stroke.y && y <= stroke.y + stroke.height) {
                        return {id: formulaId, ...formulaObj};
                    }
                }
            }
            return null;
        }
        
        function removeFormula(formulaId) {
            if (formulaObjects.has(formulaId)) {
                // å¾strokesä¸­ç§»é™¤
                const formulaObj = formulaObjects.get(formulaId);
                const strokeIndex = strokes.indexOf(formulaObj.stroke);
                if (strokeIndex > -1) {
                    strokes.splice(strokeIndex, 1);
                }
                
                // å¾ç®¡ç†ç³»çµ±ä¸­ç§»é™¤
                formulaObjects.delete(formulaId);
                const layerIndex = layerOrder.indexOf(formulaId);
                if (layerIndex > -1) {
                    layerOrder.splice(layerIndex, 1);
                }
                
                redrawCanvas();
                console.log('ğŸ—‘ï¸  å·²ç§»é™¤å…¬å¼:', formulaId);
                return true;
            }
            return false;
        }
        
        // â­ æ–°å¢ï¼šå…¬å¼åœ–å±¤ç®¡ç†åŠŸèƒ½
        function bringFormulaToFront(formulaId) {
            const index = layerOrder.indexOf(formulaId);
            if (index > -1) {
                layerOrder.splice(index, 1);
                layerOrder.push(formulaId);
                redrawCanvas();
                console.log('â¬†ï¸ å…¬å¼å·²ç½®é ‚:', formulaId);
                return true;
            }
            return false;
        }
        
        function sendFormulaToBack(formulaId) {
            const index = layerOrder.indexOf(formulaId);
            if (index > -1) {
                layerOrder.splice(index, 1);
                layerOrder.unshift(formulaId);
                redrawCanvas();
                console.log('â¬‡ï¸ å…¬å¼å·²ç½®åº•:', formulaId);
                return true;
            }
            return false;
        }
        
        function moveFormulaUp(formulaId) {
            const index = layerOrder.indexOf(formulaId);
            if (index > -1 && index < layerOrder.length - 1) {
                [layerOrder[index], layerOrder[index + 1]] = [layerOrder[index + 1], layerOrder[index]];
                redrawCanvas();
                console.log('â†‘ å…¬å¼ä¸Šç§»ä¸€å±¤:', formulaId);
                return true;
            }
            return false;
        }
        
        function moveFormulaDown(formulaId) {
            const index = layerOrder.indexOf(formulaId);
            if (index > 0) {
                [layerOrder[index], layerOrder[index - 1]] = [layerOrder[index - 1], layerOrder[index]];
                redrawCanvas();
                console.log('â†“ å…¬å¼ä¸‹ç§»ä¸€å±¤:', formulaId);
                return true;
            }
            return false;
        }
        
        // åœˆé¸åŠŸèƒ½è®Šé‡
        let isSelecting = false; // æ˜¯å¦è™•æ–¼åœˆé¸ç‹€æ…‹
        let isReadyToSelect = false; // æº–å‚™åœˆé¸ï¼ˆé»æ“ŠæŒ‰éˆ•å¾Œï¼Œç­‰å¾…ç”¨æˆ¶åœ¨ç•«å¸ƒä¸Šé»æ“Šï¼‰
        let selectionStart = {x: 0, y: 0};
        let selectionEnd = {x: 0, y: 0};
        let currentSelection = null;
        
        // é¸å–æ“ä½œçµ„ç‹€æ…‹ç®¡ç†
        let selectionOperation = null; // 'select', 'move', null
        
        // æŒ‰éˆ•è®Šé‡ï¼ˆå…¨å±€ä½œç”¨åŸŸï¼‰
        let selectAreaBtn = null;
        let moveBtn = null;
        let scaleBtn = null;
        let deleteBtn = null;
        
        // ç§»å‹•åŠŸèƒ½è®Šé‡
        let isMoving = false; // ç§»å‹•æ¨¡å¼ç‹€æ…‹
        let isDragging = false; // æ˜¯å¦æ­£åœ¨æ‹–æ‹½ç§»å‹•
        let moveStartPoint = {x: 0, y: 0}; // ç§»å‹•èµ·å§‹é»
        let selectedItems = []; // é¸ä¸­çš„é …ç›®é™£åˆ—
        let tempMoveDeltas = null; // æš«å­˜ç§»å‹•çš„ç´¯ç©å¢é‡ï¼ˆç”¨æ–¼ Commandï¼‰
        
        // å…¶ä»–æ“ä½œåŠŸèƒ½è®Šé‡
        let isScaling = false; // ç¸®æ”¾æ¨¡å¼ç‹€æ…‹
        let isDeleting = false; // åˆªé™¤æ¨¡å¼ç‹€æ…‹
        
        // ç¸®æ”¾åŠŸèƒ½è®Šé‡
        let scalingBounds = null; // é¸ä¸­ç‰©ä»¶çš„é‚Šç•Œæ¡†
        let scalingCorner = null; // ç•¶å‰æ‹–æ‹½çš„è§’è½ ('se' å³ä¸‹è§’)
        let scalingStartPoint = {x: 0, y: 0}; // ç¸®æ”¾æ‹–æ‹½èµ·å§‹é»
        let scalingInitialBounds = null; // ç¸®æ”¾é–‹å§‹æ™‚çš„é‚Šç•Œæ¡†
        let scalingInitialItems = null; // ç¸®æ”¾é–‹å§‹æ™‚çš„é …ç›®åˆå§‹ç‹€æ…‹
        let lastScalingRatio = 1.0; // è¨˜éŒ„æœ€å¾Œä¸€æ¬¡ç¸®æ”¾æ¯”ä¾‹
        
        // ===== Command Pattern ç³»çµ± =====
        
        // è¼”åŠ©ï¼šä¾ ID æŸ¥æ‰¾ç´¢å¼•ï¼ˆé¿å…ç´¢å¼•æ¼‚ç§»ï¼‰
        function findStrokeIndexById(id) {
            if (!id) return -1;
            for (let i = 0; i < strokes.length; i++) {
                const s = strokes[i];
                if (s && s.id === id) return i;
            }
            return -1;
        }
        function findImageIndexById(id) {
            if (!id) return -1;
            for (let i = 0; i < images.length; i++) {
                const im = images[i];
                if (im && im.id === id) return i;
            }
            return -1;
        }

        // â­ Command åŸºç¤é¡
        class Command {
            execute() {
                throw new Error('å¿…é ˆå¯¦ä½œ execute() æ–¹æ³•');
            }
            
            undo() {
                throw new Error('å¿…é ˆå¯¦ä½œ undo() æ–¹æ³•');
            }
            
            redo() {
                this.execute(); // é è¨­ redo å°±æ˜¯é‡æ–°åŸ·è¡Œ
            }
        }
        
        // â­ æ­·å²ç®¡ç†å™¨
        class HistoryManager {
            constructor() {
                this.history = [];
                this.currentIndex = -1;
                this.maxHistory = 100; // æœ€å¤šä¿å­˜ 100 æ­¥
            }
            
            execute(command) {
                // åŸ·è¡ŒæŒ‡ä»¤
                command.execute();
                
                // æ¸…é™¤ redo æ­·å²ï¼ˆç•¶ç”¨æˆ¶åŸ·è¡Œæ–°æ“ä½œæ™‚ï¼‰
                this.history = this.history.slice(0, this.currentIndex + 1);
                
                // æ·»åŠ åˆ°æ­·å²
                this.history.push(command);
                this.currentIndex++;
                
                // é™åˆ¶æ­·å²é•·åº¦
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.currentIndex--;
                }
                
                console.log(`âœ… åŸ·è¡ŒæŒ‡ä»¤: ${command.constructor.name}ï¼Œæ­·å²æ­¥æ•¸: ${this.currentIndex + 1}/${this.history.length}`);
                this.updateUI();
            }
            
            undo() {
                if (!this.canUndo()) {
                    console.log('âš ï¸ ç„¡æ³•å›ä¸Šä¸€æ­¥');
                    return false;
                }
                
                this.history[this.currentIndex].undo();
                this.currentIndex--;
                console.log(`â¬…ï¸ å›ä¸Šä¸€æ­¥ï¼Œç›®å‰æ­¥æ•¸: ${this.currentIndex + 1}/${this.history.length}`);
                redrawCanvas();
                this.updateUI();
                return true;
            }
            
            redo() {
                if (!this.canRedo()) {
                    console.log('âš ï¸ ç„¡æ³•é‡åš');
                    return false;
                }
                
                this.currentIndex++;
                this.history[this.currentIndex].redo();
                console.log(`â¡ï¸ é‡åšï¼Œç›®å‰æ­¥æ•¸: ${this.currentIndex + 1}/${this.history.length}`);
                redrawCanvas();
                this.updateUI();
                return true;
            }
            
            canUndo() {
                return this.currentIndex >= 0;
            }
            
            canRedo() {
                return this.currentIndex < this.history.length - 1;
            }
            
            clear() {
                this.history = [];
                this.currentIndex = -1;
                console.log('ğŸ—‘ï¸ æ¸…é™¤æ­·å²è¨˜éŒ„');
                this.updateUI();
            }
            
            updateUI() {
                // æ›´æ–° UI æŒ‰éˆ•ç‹€æ…‹ï¼ˆç¨å¾Œå¯¦ä½œï¼‰
                if (typeof updateHistoryUI === 'function') {
                    updateHistoryUI();
                }
            }
        }
        
        // â­ å‰µå»ºå…¨å±€æ­·å²ç®¡ç†å™¨
        const historyManager = new HistoryManager();
        
        // ===== Command å¯¦ä½œé¡åˆ¥ =====
        
        // â­ 1. ç¹ªè£½ç­†ç•«æŒ‡ä»¤
        class DrawStrokeCommand extends Command {
            constructor(stroke) {
                super();
                this.stroke = stroke;
            }
            
            execute() {
                // ç¢ºä¿æ¯å€‹ç­†ç•«æœ‰ç©©å®š ID
                if (!this.stroke.id) {
                    this.stroke.id = 'stroke_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);
                }
                strokes.push(this.stroke);
                console.log('âœï¸ ç¹ªè£½ç­†ç•«ï¼Œç¸½æ•¸:', strokes.length);
            }
            
            undo() {
                const index = strokes.indexOf(this.stroke);
                if (index > -1) {
                    strokes.splice(index, 1);
                    console.log('â†©ï¸ ç§»é™¤ç­†ç•«ï¼Œå‰©é¤˜:', strokes.length);
                }
            }
        }
        
        // â­ 2. æ·»åŠ æ•¸å­¸å…¬å¼æŒ‡ä»¤
        class AddFormulaCommand extends Command {
            constructor(formulaStroke, formulaId) {
                super();
                this.formulaStroke = formulaStroke;
                this.formulaId = formulaId;
                this.strokeIndex = -1;
                this.metadata = null;
            }
            
            execute() {
                // æ·»åŠ åˆ° strokes
                this.strokeIndex = strokes.push(this.formulaStroke) - 1;
                
                // æ·»åŠ åˆ°å…¬å¼ç®¡ç†ç³»çµ±
                this.metadata = {
                    createdAt: Date.now(),
                    layer: layerOrder.length
                };
                
                formulaObjects.set(this.formulaId, {
                    stroke: this.formulaStroke,
                    metadata: this.metadata
                });
                
                layerOrder.push(this.formulaId);
                
                console.log('â• æ·»åŠ æ•¸å­¸å…¬å¼:', this.formulaId);
            }
            
            undo() {
                // å¾ strokes ä¸­ç§»é™¤
                if (this.strokeIndex >= 0 && this.strokeIndex < strokes.length) {
                    strokes.splice(this.strokeIndex, 1);
                }
                
                // å¾å…¬å¼ç®¡ç†ç³»çµ±ä¸­ç§»é™¤
                formulaObjects.delete(this.formulaId);
                const layerIndex = layerOrder.indexOf(this.formulaId);
                if (layerIndex > -1) {
                    layerOrder.splice(layerIndex, 1);
                }
                
                console.log('â†©ï¸ ç§»é™¤æ•¸å­¸å…¬å¼:', this.formulaId);
            }
        }
        
        // â­ 2.5 æ–°å¢åœ–ç‰‡æŒ‡ä»¤
        class AddImageCommand extends Command {
            constructor(imageObj) {
                super();
                this.image = imageObj;
                this.insertIndex = -1;
            }
            execute() {
                if (!this.image.id) {
                    this.image.id = 'image_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);
                }
                this.insertIndex = images.push(this.image) - 1;
                console.log('â• æ·»åŠ åœ–ç‰‡:', this.image.id);
            }
            undo() {
                const idx = this.image.id ? findImageIndexById(this.image.id) : this.insertIndex;
                if (idx >= 0 && idx < images.length) {
                    images.splice(idx, 1);
                    console.log('â†©ï¸ ç§»é™¤åœ–ç‰‡:', this.image.id);
                }
            }
        }
        
        // â­ 3. ç§»å‹•ç‰©ä»¶æŒ‡ä»¤
        class MoveItemsCommand extends Command {
            constructor(items, deltaX, deltaY) {
                super();
                this.items = JSON.parse(JSON.stringify(items)); // æ·±æ‹·è²
                this.deltaX = deltaX;
                this.deltaY = deltaY;
            }
            
            execute() {
                this.items.forEach(item => {
                    this.moveItem(item, this.deltaX, this.deltaY);
                });
                console.log('ğŸ–ï¸ ç§»å‹•ç‰©ä»¶:', this.items.length, 'å€‹');
            }
            
            undo() {
                this.items.forEach(item => {
                    this.moveItem(item, -this.deltaX, -this.deltaY);
                });
                console.log('â†©ï¸ å¾©åŸç§»å‹•:', this.items.length, 'å€‹');
            }
            
            moveItem(item, dx, dy) {
                if (item.tool === 'formula' || item.tool === 'image') {
                    if (item.sourceArray === 'strokes') {
                        const idx = item.id ? findStrokeIndexById(item.id) : item.index;
                        if (idx >= 0 && idx < strokes.length) {
                            strokes[idx].x += dx;
                            strokes[idx].y += dy;
                        }
                    } else if (item.sourceArray === 'images') {
                        const idx = item.id ? findImageIndexById(item.id) : item.index;
                        if (idx >= 0 && idx < images.length) {
                            images[idx].x += dx;
                            images[idx].y += dy;
                        }
                    }
                } else if (item.tool === 'stroke' && item.sourceArray === 'strokes') {
                    const idx = item.id ? findStrokeIndexById(item.id) : item.index;
                    if (idx >= 0 && idx < strokes.length) {
                        strokes[idx].points.forEach(point => {
                            point.x += dx;
                            point.y += dy;
                        });
                    }
                }
            }
        }
        
        // â­ 4. ç¸®æ”¾ç‰©ä»¶æŒ‡ä»¤
        class ScaleItemsCommand extends Command {
            constructor(items, centerX, centerY, ratio) {
                super();
                this.items = JSON.parse(JSON.stringify(items)); // æ·±æ‹·è²
                this.centerX = centerX;
                this.centerY = centerY;
                this.ratio = ratio;
                this.originalStates = this.saveStates();
            }
            
            saveStates() {
                return this.items.map(item => {
                    if (item.sourceArray === 'strokes') {
                        const idx = item.id ? findStrokeIndexById(item.id) : item.index;
                        if (idx >= 0 && idx < strokes.length) {
                            const stroke = strokes[idx];
                            return {
                                id: stroke.id,
                                index: idx,
                                sourceArray: item.sourceArray,
                                x: stroke.x,
                                y: stroke.y,
                                width: stroke.width,
                                height: stroke.height,
                                points: stroke.points ? JSON.parse(JSON.stringify(stroke.points)) : null
                            };
                        }
                    } else if (item.sourceArray === 'images') {
                        const idx = item.id ? findImageIndexById(item.id) : item.index;
                        if (idx >= 0 && idx < images.length) {
                            const image = images[idx];
                            return {
                                id: image.id,
                                index: idx,
                                sourceArray: item.sourceArray,
                                x: image.x,
                                y: image.y,
                                width: image.width,
                                height: image.height
                            };
                        }
                    }
                    return null;
                }).filter(s => s !== null);
            }
            
            execute() {
                this.applyScale(this.ratio);
                console.log('ğŸ” ç¸®æ”¾ç‰©ä»¶ï¼Œæ¯”ä¾‹:', this.ratio);
            }
            
            undo() {
                // æ¢å¾©åŸå§‹ç‹€æ…‹ï¼ˆä»¥ ID æŸ¥æ‰¾ï¼Œé¿å…ç´¢å¼•æ¼‚ç§»ï¼‰
                this.originalStates.forEach(state => {
                    if (state.sourceArray === 'strokes') {
                        const idx = state.id ? findStrokeIndexById(state.id) : state.index;
                        if (!(idx >= 0 && idx < strokes.length)) return;
                        const stroke = strokes[idx];
                        if (state.points) {
                            stroke.points = JSON.parse(JSON.stringify(state.points));
                        } else {
                            stroke.x = state.x;
                            stroke.y = state.y;
                            stroke.width = state.width;
                            stroke.height = state.height;
                        }
                    } else if (state.sourceArray === 'images') {
                        const idx = state.id ? findImageIndexById(state.id) : state.index;
                        if (!(idx >= 0 && idx < images.length)) return;
                        images[idx].x = state.x;
                        images[idx].y = state.y;
                        images[idx].width = state.width;
                        images[idx].height = state.height;
                    }
                });
                console.log('â†©ï¸ å¾©åŸç¸®æ”¾');
            }
            
            applyScale(ratio) {
                this.originalStates.forEach(state => {
                    if (state.sourceArray === 'strokes') {
                        const idx = state.id ? findStrokeIndexById(state.id) : state.index;
                        if (!(idx >= 0 && idx < strokes.length)) return;
                        const stroke = strokes[idx];
                        if (state.points) {
                            // ç­†ç•«
                            stroke.points = state.points.map(point => ({
                                x: this.centerX + (point.x - this.centerX) * ratio,
                                y: this.centerY + (point.y - this.centerY) * ratio
                            }));
                        } else {
                            // å…¬å¼
                            const oldCenterX = state.x + state.width / 2;
                            const oldCenterY = state.y + state.height / 2;
                            stroke.width = state.width * ratio;
                            stroke.height = state.height * ratio;
                            stroke.x = this.centerX + (oldCenterX - this.centerX) * ratio - stroke.width / 2;
                            stroke.y = this.centerY + (oldCenterY - this.centerY) * ratio - stroke.height / 2;
                        }
                    } else if (state.sourceArray === 'images') {
                        const idx = state.id ? findImageIndexById(state.id) : state.index;
                        if (!(idx >= 0 && idx < images.length)) return;
                        const image = images[idx];
                        const oldCenterX = state.x + state.width / 2;
                        const oldCenterY = state.y + state.height / 2;
                        image.width = state.width * ratio;
                        image.height = state.height * ratio;
                        image.x = this.centerX + (oldCenterX - this.centerX) * ratio - image.width / 2;
                        image.y = this.centerY + (oldCenterY - this.centerY) * ratio - image.height / 2;
                    }
                });
            }
        }
        
        // â­ 5. æ¸…é™¤ç•«å¸ƒæŒ‡ä»¤
        class ClearCanvasCommand extends Command {
            constructor() {
                super();
                this.savedStrokes = [];
                this.savedImages = [];
                this.savedFormulaObjects = new Map();
                this.savedLayerOrder = [];
            }
            
            execute() {
                // ä¿å­˜ç•¶å‰ç‹€æ…‹
                this.savedStrokes = [...strokes];
                this.savedImages = [...images];
                this.savedFormulaObjects = new Map(formulaObjects);
                this.savedLayerOrder = [...layerOrder];
                
                // æ¸…é™¤
                strokes.length = 0;
                images.length = 0;
                formulaObjects.clear();
                layerOrder.length = 0;
                
                console.log('ğŸ—‘ï¸ æ¸…é™¤ç•«å¸ƒ');
            }
            
            undo() {
                // æ¢å¾©
                strokes.push(...this.savedStrokes);
                images.push(...this.savedImages);
                this.savedFormulaObjects.forEach((value, key) => {
                    formulaObjects.set(key, value);
                });
                layerOrder.push(...this.savedLayerOrder);
                
                console.log('â†©ï¸ å¾©åŸæ¸…é™¤');
            }
        }
        
        // â­ 6. åˆªé™¤ç‰©ä»¶æŒ‡ä»¤
        class DeleteItemsCommand extends Command {
            constructor(items) {
                super();
                this.items = JSON.parse(JSON.stringify(items)); // æ·±æ‹·è²
                this.deletedStrokes = [];
                this.deletedImages = [];
                this.deletedFormulas = new Map();
            }
            
            execute() {
                // å¾å¾Œå¾€å‰åˆªé™¤ï¼ˆé¿å… index éŒ¯äº‚ï¼‰
                const sortedItems = [...this.items].sort((a, b) => {
                    // ä»¥ sourceArray åˆ†çµ„å¾Œï¼Œç›¡é‡ç”¨ id æ‰¾ç¾è¡Œç´¢å¼•ï¼Œå¦å‰‡é€€å› index
                    const idxA = a.sourceArray === 'strokes' ? (a.id ? findStrokeIndexById(a.id) : a.index) : (a.id ? findImageIndexById(a.id) : a.index);
                    const idxB = b.sourceArray === 'strokes' ? (b.id ? findStrokeIndexById(b.id) : b.index) : (b.id ? findImageIndexById(b.id) : b.index);
                    return (idxB - idxA);
                });
                
                sortedItems.forEach(item => {
                    if (item.sourceArray === 'strokes') {
                        const idx = item.id ? findStrokeIndexById(item.id) : item.index;
                        if (!(idx >= 0 && idx < strokes.length)) return;
                        const deleted = strokes.splice(idx, 1)[0];
                        this.deletedStrokes.push({index: item.index, stroke: deleted});
                        
                        // å¦‚æœæ˜¯å…¬å¼ï¼Œä¹Ÿå¾ formulaObjects ä¸­ç§»é™¤
                        if (deleted.id) {
                            const formulaData = formulaObjects.get(deleted.id);
                            if (formulaData) {
                                this.deletedFormulas.set(deleted.id, formulaData);
                                formulaObjects.delete(deleted.id);
                                const layerIndex = layerOrder.indexOf(deleted.id);
                                if (layerIndex > -1) {
                                    layerOrder.splice(layerIndex, 1);
                                }
                            }
                        }
                    } else if (item.sourceArray === 'images') {
                        const idx = item.id ? findImageIndexById(item.id) : item.index;
                        if (!(idx >= 0 && idx < images.length)) return;
                        const deleted = images.splice(idx, 1)[0];
                        this.deletedImages.push({index: item.index, image: deleted});
                    }
                });
                
                console.log('ğŸ—‘ï¸ åˆªé™¤ç‰©ä»¶:', this.items.length, 'å€‹');
            }
            
            undo() {
                // æŒ‰åŸé †åºæ’å…¥å›å»
                this.deletedStrokes.sort((a, b) => a.index - b.index);
                this.deletedStrokes.forEach(({index, stroke}) => {
                    // å„ªå…ˆç”¨åŸ id å®šä½æ’å›è¿‘ä¼¼ä½ç½®ï¼›è‹¥æ‰¾ä¸åˆ°å‰‡ä½¿ç”¨åŸ index
                    const existingIdx = stroke.id ? findStrokeIndexById(stroke.id) : -1;
                    if (existingIdx === -1) {
                        strokes.splice(Math.min(index, strokes.length), 0, stroke);
                    } else {
                        strokes.splice(existingIdx, 0, stroke);
                    }
                });
                
                this.deletedImages.sort((a, b) => a.index - b.index);
                this.deletedImages.forEach(({index, image}) => {
                    const existingIdx = image.id ? findImageIndexById(image.id) : -1;
                    if (existingIdx === -1) {
                        images.splice(Math.min(index, images.length), 0, image);
                    } else {
                        images.splice(existingIdx, 0, image);
                    }
                });
                
                // æ¢å¾©å…¬å¼
                this.deletedFormulas.forEach((formulaData, formulaId) => {
                    formulaObjects.set(formulaId, formulaData);
                    layerOrder.push(formulaId);
                });
                
                console.log('â†©ï¸ å¾©åŸåˆªé™¤');
            }
        }
        
        // ===== é¸å–æ“ä½œçµ„ç®¡ç†å‡½æ•¸ =====
        function setSelectionOperation(op) {
            console.log('ğŸ”„ setSelectionOperation è¢«å‘¼å«, ç•¶å‰:', selectionOperation, 'â†’ æ–°:', op);
            
            // â­ æ­¥é©Ÿ 1: å…ˆé‡ç½®æ‰€æœ‰ç‹€æ…‹å’ŒæŒ‰éˆ•æ¨£å¼ï¼ˆç„¡è«–åˆ‡æ›åˆ°ä»€éº¼æ¨¡å¼ï¼‰
            isDrawing = false;
            isSelecting = false;
                isReadyToSelect = false;
            isDragging = false;
                isMoving = false;
                isScaling = false;
                isDeleting = false;
            selectedItems = [];
            
            // â­ æ¸…é™¤ç¸®æ”¾ç›¸é—œç‹€æ…‹
            scalingBounds = null;
            scalingCorner = null;
            scalingStartPoint = {x: 0, y: 0};
            scalingInitialBounds = null;
            scalingInitialItems = null;
            
            // é‡ç½®æ‰€æœ‰æŒ‰éˆ•æ¨£å¼ç‚ºç°åº•
            if (selectAreaBtn) selectAreaBtn.style.background = '#95a5a6';
            if (moveBtn) moveBtn.style.background = '#95a5a6';
            if (scaleBtn) scaleBtn.style.background = '#95a5a6';
            if (deleteBtn) deleteBtn.style.background = '#95a5a6';
            
            // â­ æ­¥é©Ÿ 2: å¦‚æœè¦å–æ¶ˆæ¨¡å¼ï¼ˆop === nullï¼‰ï¼Œé¡¯ç¤ºå–æ¶ˆè¨Šæ¯ä¸¦è¿”å›
            if (op === null) {
                selectionOperation = null;
                updateCanvasCursor();
                redrawCanvas(); // â­ é‡ç¹ªç•«å¸ƒä»¥æ¸…é™¤é‚Šç•Œæ¡†
                addChatMessage('AI', 'âŒ **å·²å–æ¶ˆæ“ä½œæ¨¡å¼ï¼Œå›åˆ°ç¹ªåœ–æ¨¡å¼**');
                console.log('âœ… å·²é‡ç½®ç‚ºç¹ªåœ–æ¨¡å¼');
                return;
            }
            
            // â­ æ­¥é©Ÿ 3: è¨­ç½®æ–°æ“ä½œæ¨¡å¼
            selectionOperation = op;
            
            if (op === 'select') {
                isReadyToSelect = true;
                selectAreaBtn.style.background = '#e74c3c';
                addChatMessage('AI', 'ğŸ”² **åœˆé¸æ¨¡å¼å·²æ¿€æ´»**\n\nè«‹åœ¨ç•«å¸ƒä¸Šæ‹–å‹•æ»‘é¼ åœˆé¸å€åŸŸã€‚');
                console.log('âœ… åœˆé¸æ¨¡å¼å·²æ¿€æ´», isReadyToSelect:', isReadyToSelect);
            } else if (op === 'move') {
                isMoving = true;
                moveBtn.style.background = '#e74c3c';
                addChatMessage('AI', 'ğŸ–ï¸ **ç§»å‹•æ¨¡å¼å·²æ¿€æ´»**\n\nè«‹åœˆé¸è¦ç§»å‹•çš„å…§å®¹ï¼Œç„¶å¾Œæ‹–æ‹½ç§»å‹•ã€‚');
                console.log('âœ… ç§»å‹•æ¨¡å¼å·²æ¿€æ´», isMoving:', isMoving);
            } else if (op === 'scale') {
                isScaling = true;
                scaleBtn.style.background = '#e74c3c';
                addChatMessage('AI', 'ğŸ” **ç¸®æ”¾æ¨¡å¼å·²æ¿€æ´»**\n\nè«‹åœˆé¸è¦ç¸®æ”¾çš„å€åŸŸï¼Œç„¶å¾Œæ‹–æ‹½ç¸®æ”¾ã€‚');
                console.log('âœ… ç¸®æ”¾æ¨¡å¼å·²æ¿€æ´», isScaling:', isScaling);
            } else if (op === 'delete') {
                isDeleting = true;
                deleteBtn.style.background = '#e74c3c';
                addChatMessage('AI', 'ğŸ—‘ï¸ **åˆªé™¤æ¨¡å¼å·²æ¿€æ´»**\n\nè«‹åœˆé¸è¦åˆªé™¤çš„å€åŸŸï¼Œç„¶å¾Œæ‹–æ‹½åˆªé™¤ã€‚');
                console.log('âœ… åˆªé™¤æ¨¡å¼å·²æ¿€æ´», isDeleting:', isDeleting);
            }
            
            updateCanvasCursor();
        }
        
        // ===== å…¨å±€ç¹ªåœ–å‡½æ•¸ =====
            
            // â­ è¨ˆç®—é¸ä¸­ç‰©ä»¶çš„é‚Šç•Œæ¡†
            function calculateScalingBounds() {
                if (selectedItems.length === 0) {
                    scalingBounds = null;
                    console.log('ğŸ“ ç„¡é¸ä¸­é …ç›®ï¼Œæ¸…é™¤é‚Šç•Œæ¡†');
                    return;
                }
                
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                console.log('ğŸ“ é–‹å§‹è¨ˆç®—é‚Šç•Œæ¡†ï¼Œé¸ä¸­é …ç›®æ•¸:', selectedItems.length);
                
                selectedItems.forEach((item, idx) => {
                    if (item.tool === 'formula' || item.tool === 'image') {
                        console.log(`   é …ç›® ${idx} (${item.tool}): x=${item.x.toFixed(1)}, y=${item.y.toFixed(1)}, w=${item.width.toFixed(1)}, h=${item.height.toFixed(1)}`);
                        minX = Math.min(minX, item.x);
                        minY = Math.min(minY, item.y);
                        maxX = Math.max(maxX, item.x + item.width);
                        maxY = Math.max(maxY, item.y + item.height);
                    } else if (item.tool === 'stroke' && item.bounds) {
                        console.log(`   é …ç›® ${idx} (stroke): bounds.x=${item.bounds.x.toFixed(1)}, bounds.y=${item.bounds.y.toFixed(1)}, w=${item.bounds.width.toFixed(1)}, h=${item.bounds.height.toFixed(1)}`);
                        minX = Math.min(minX, item.bounds.x);
                        minY = Math.min(minY, item.bounds.y);
                        maxX = Math.max(maxX, item.bounds.x + item.bounds.width);
                        maxY = Math.max(maxY, item.bounds.y + item.bounds.height);
                    }
                });
                
                scalingBounds = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY,
                    centerX: (minX + maxX) / 2,
                    centerY: (minY + maxY) / 2
                };
                
                console.log('ğŸ“ æœ€çµ‚é‚Šç•Œæ¡†:', {
                    x: scalingBounds.x.toFixed(1),
                    y: scalingBounds.y.toFixed(1),
                    width: scalingBounds.width.toFixed(1),
                    height: scalingBounds.height.toFixed(1),
                    centerX: scalingBounds.centerX.toFixed(1),
                    centerY: scalingBounds.centerY.toFixed(1)
                });
            }
            
            // â­ ç¹ªè£½ç¸®æ”¾é‚Šç•Œæ¡†
            function drawScalingBounds() {
                if (!scalingBounds || !isScaling) return;
                
                ctx.save();
                
                // ç¹ªè£½é‚Šç•Œæ¡†
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(scalingBounds.x, scalingBounds.y, scalingBounds.width, scalingBounds.height);
                
                // â­ åªç¹ªè£½å³ä¸‹è§’æ§åˆ¶é»
                const cornerSize = 12;
                const seX = scalingBounds.x + scalingBounds.width;
                const seY = scalingBounds.y + scalingBounds.height;
                
                ctx.fillStyle = '#e74c3c';
                ctx.setLineDash([]);
                ctx.fillRect(seX - cornerSize/2, seY - cornerSize/2, cornerSize, cornerSize);
                
                // ç¹ªè£½ä¸­å¿ƒé»
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(scalingBounds.centerX, scalingBounds.centerY, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            // â­ æª¢æ¸¬æ»‘é¼ æ˜¯å¦åœ¨å³ä¸‹è§’æ§åˆ¶é»ä¸Š
            function getCornerAtPoint(x, y) {
                if (!scalingBounds) return null;
                
                const cornerSize = 12;
                
                // â­ åªæª¢æ¸¬å³ä¸‹è§’ï¼ˆSEï¼‰ä¾æ“šç´…æ–¹å¡Šå¯¦éš›é‚Šç•Œ
                const seX = scalingBounds.x + scalingBounds.width;
                const seY = scalingBounds.y + scalingBounds.height;
                
                if (x >= seX - cornerSize/2 && x <= seX + cornerSize/2 &&
                    y >= seY - cornerSize/2 && y <= seY + cornerSize/2) {
                    return 'se';
                }
                
                return null;
            }
            
            // â­ è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ï¼ˆåªé‡å°å³ä¸‹è§’ SEï¼‰
            function calculateScaleRatio(corner, currentX, currentY) {
                if (!scalingInitialBounds) return 1.0;
                
                const centerX = scalingInitialBounds.centerX;
                const centerY = scalingInitialBounds.centerY;
                
                // å³ä¸‹è§’ï¼šè¨ˆç®—åˆ°ä¸­å¿ƒé»çš„è·é›¢
                const initialDx = scalingInitialBounds.x + scalingInitialBounds.width - centerX;
                const initialDy = scalingInitialBounds.y + scalingInitialBounds.height - centerY;
                const initialDist = Math.sqrt(initialDx * initialDx + initialDy * initialDy);
                
                const currentDx = currentX - centerX;
                const currentDy = currentY - centerY;
                const currentDist = Math.sqrt(currentDx * currentDx + currentDy * currentDy);
                
                const ratio = currentDist / initialDist;
                
                // â­ å‹•æ…‹è¨ˆç®—ç¸®æ”¾é™åˆ¶
                // æœ€å°ï¼šç¸®åˆ°åŸå§‹å¤§å°çš„ 10%ï¼ˆé¿å…å¤ªå°çœ‹ä¸è¦‹ï¼‰
                // æœ€å¤§ï¼šæ ¹æ“šç•«å¸ƒå¤§å°å‹•æ…‹è¨ˆç®—ï¼Œé¿å…è¶…å‡ºç•«å¸ƒå¤ªå¤š
                const canvasMaxDimension = Math.max(canvas.width, canvas.height);
                const currentMaxDimension = Math.max(scalingInitialBounds.width, scalingInitialBounds.height);
                
                // æœ€å¤§æ¯”ä¾‹ï¼šç¢ºä¿ç¸®æ”¾å¾Œä¸è¶…éç•«å¸ƒå¤§å°çš„ 2 å€
                const maxRatio = Math.min(10.0, (canvasMaxDimension * 2) / currentMaxDimension);
                const minRatio = 0.1; // æœ€å° 10%
                
                const clampedRatio = Math.max(minRatio, Math.min(maxRatio, ratio));
                
                if (clampedRatio !== ratio) {
                    console.log(`âš ï¸ ç¸®æ”¾æ¯”ä¾‹å·²é™åˆ¶: ${ratio.toFixed(2)} â†’ ${clampedRatio.toFixed(2)} (ç¯„åœ: ${minRatio} ~ ${maxRatio.toFixed(1)})`);
                }
                
                return clampedRatio;
            }
            
            // â­ æ‡‰ç”¨ç¸®æ”¾ï¼ˆä¿®å¾©ç‰ˆï¼šåŸºæ–¼åˆå§‹ç‹€æ…‹ï¼Œé¿å…ç´¯ç©èª¤å·®ï¼‰
            function applyScale(ratio) {
                if (!scalingInitialBounds || !selectedItems || selectedItems.length === 0) {
                    console.warn('âš ï¸ applyScale ä¸­æ­¢ï¼šç¼ºå°‘å¿…è¦æ•¸æ“š');
                    return;
                }
                
                const centerX = scalingInitialBounds.centerX;
                const centerY = scalingInitialBounds.centerY;
                
                console.log(`ğŸ” applyScale åŸ·è¡Œï¼šratio=${ratio.toFixed(2)}, center=(${centerX.toFixed(1)}, ${centerY.toFixed(1)})`);
                
                // â­ ç‚ºæ¯å€‹é¸ä¸­é …ç›®ä¿å­˜åˆå§‹ç‹€æ…‹ï¼ˆåªåœ¨ç¬¬ä¸€æ¬¡æ‹–æ‹½æ™‚ä¿å­˜ï¼‰
                if (!scalingInitialItems) {
                    console.log('ğŸ’¾ é¦–æ¬¡ç¸®æ”¾ï¼Œä¿å­˜åˆå§‹ç‹€æ…‹');
                    scalingInitialItems = selectedItems.map(item => ({
                        tool: item.tool,
                        sourceArray: item.sourceArray,
                        index: item.index,
                        x: item.tool === 'formula' || item.tool === 'image' ? item.x : undefined,
                        y: item.tool === 'formula' || item.tool === 'image' ? item.y : undefined,
                        width: item.tool === 'formula' || item.tool === 'image' ? item.width : undefined,
                        height: item.tool === 'formula' || item.tool === 'image' ? item.height : undefined,
                        points: item.tool === 'stroke' ? JSON.parse(JSON.stringify(item.points)) : undefined
                    }));
                }
                
                // æ ¹æ“šåˆå§‹ç‹€æ…‹è¨ˆç®—æ–°ç‹€æ…‹
                scalingInitialItems.forEach((initialItem, idx) => {
                    const item = selectedItems[idx];
                    
                    // ç¸®æ”¾æ•¸å­¸å…¬å¼
                    if (initialItem.tool === 'formula') {
                        const initialCenterX = initialItem.x + initialItem.width / 2;
                        const initialCenterY = initialItem.y + initialItem.height / 2;
                        
                        const newWidth = initialItem.width * ratio;
                        const newHeight = initialItem.height * ratio;
                        const newX = centerX + (initialCenterX - centerX) * ratio - newWidth / 2;
                        const newY = centerY + (initialCenterY - centerY) * ratio - newHeight / 2;
                        
                        // â­ åŒæ™‚æ›´æ–° selectedItems å’ŒåŸå§‹ strokes é™£åˆ—
                        if (initialItem.sourceArray === 'strokes' && initialItem.index >= 0 && initialItem.index < strokes.length) {
                            // æ›´æ–°åŸå§‹é™£åˆ—
                            strokes[initialItem.index].x = newX;
                            strokes[initialItem.index].y = newY;
                            strokes[initialItem.index].width = newWidth;
                            strokes[initialItem.index].height = newHeight;
                            
                            // â­ åŒæ­¥æ›´æ–° selectedItemsï¼ˆç”¨æ–¼é‡æ–°è¨ˆç®—é‚Šç•Œæ¡†ï¼‰
                            item.x = newX;
                            item.y = newY;
                            item.width = newWidth;
                            item.height = newHeight;
                            if (item.bounds) {
                                item.bounds.x = newX;
                                item.bounds.y = newY;
                                item.bounds.width = newWidth;
                                item.bounds.height = newHeight;
                            }
                        }
                    }
                    // ç¸®æ”¾åœ–ç‰‡
                    else if (initialItem.tool === 'image') {
                        const initialCenterX = initialItem.x + initialItem.width / 2;
                        const initialCenterY = initialItem.y + initialItem.height / 2;
                        
                        const newWidth = initialItem.width * ratio;
                        const newHeight = initialItem.height * ratio;
                        const newX = centerX + (initialCenterX - centerX) * ratio - newWidth / 2;
                        const newY = centerY + (initialCenterY - centerY) * ratio - newHeight / 2;
                        
                        // â­ åŒæ™‚æ›´æ–° selectedItems å’ŒåŸå§‹ images é™£åˆ—
                        if (initialItem.sourceArray === 'images' && initialItem.index >= 0 && initialItem.index < images.length) {
                            // æ›´æ–°åŸå§‹é™£åˆ—
                            images[initialItem.index].x = newX;
                            images[initialItem.index].y = newY;
                            images[initialItem.index].width = newWidth;
                            images[initialItem.index].height = newHeight;
                            
                            // â­ åŒæ­¥æ›´æ–° selectedItems
                            item.x = newX;
                            item.y = newY;
                            item.width = newWidth;
                            item.height = newHeight;
                        }
                    }
                    // ç¸®æ”¾ç­†ç•«
                    else if (initialItem.tool === 'stroke' && initialItem.points) {
                        const newPoints = initialItem.points.map(point => ({
                            x: centerX + (point.x - centerX) * ratio,
                            y: centerY + (point.y - centerY) * ratio
                        }));
                        
                        // â­ åŒæ™‚æ›´æ–° selectedItems å’ŒåŸå§‹ strokes é™£åˆ—
                        if (initialItem.sourceArray === 'strokes' && initialItem.index >= 0 && initialItem.index < strokes.length) {
                            // æ›´æ–°åŸå§‹é™£åˆ—
                            strokes[initialItem.index].points = newPoints;
                            
                            // â­ åŒæ­¥æ›´æ–° selectedItems ä¸­çš„ points
                            item.points = newPoints;
                            
                            // â­ æ›´æ–° boundsï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                            if (item.bounds) {
                                const xs = newPoints.map(p => p.x);
                                const ys = newPoints.map(p => p.y);
                                const minX = Math.min(...xs);
                                const minY = Math.min(...ys);
                                const maxX = Math.max(...xs);
                                const maxY = Math.max(...ys);
                                item.bounds.x = minX;
                                item.bounds.y = minY;
                                item.bounds.width = maxX - minX;
                                item.bounds.height = maxY - minY;
                            }
                        }
                    }
                });
                
                // â­ é‡æ–°è¨ˆç®—é‚Šç•Œæ¡†ï¼ˆä½¿ç”¨æ›´æ–°å¾Œçš„ selectedItemsï¼‰
                calculateScalingBounds();
                
                // é‡ç¹ªç•«å¸ƒ
                redrawCanvas();
            }
            
            // â­ ç¸®æ”¾é¸ä¸­é …ç›®å‡½æ•¸ï¼ˆä½¿ç”¨å›ºå®šæ¯”ä¾‹ï¼‰
            function scaleSelectedItems(ratio) {
                console.log('ğŸ” ç¸®æ”¾é …ç›®ï¼Œæ¯”ä¾‹:', ratio);
                
                if (selectedItems.length === 0) {
                    addChatMessage('AI', 'âŒ æ²’æœ‰é¸ä¸­ä»»ä½•é …ç›®');
                    return;
                }
                
                // è¨ˆç®—æ‰€æœ‰é¸ä¸­é …ç›®çš„ä¸­å¿ƒé»ï¼ˆä½œç‚ºç¸®æ”¾ä¸­å¿ƒï¼‰
                let totalX = 0, totalY = 0, count = 0;
                
                selectedItems.forEach(item => {
                    if (item.tool === 'formula' || item.tool === 'image') {
                        totalX += item.x + item.width / 2;
                        totalY += item.y + item.height / 2;
                        count++;
                    } else if (item.tool === 'stroke' && item.bounds) {
                        totalX += item.bounds.x + item.bounds.width / 2;
                        totalY += item.bounds.y + item.bounds.height / 2;
                        count++;
                    }
                });
                
                const centerX = count > 0 ? totalX / count : 0;
                const centerY = count > 0 ? totalY / count : 0;
                
                console.log('ğŸ“ ç¸®æ”¾ä¸­å¿ƒé»:', centerX.toFixed(1), centerY.toFixed(1));
                
                // ç¸®æ”¾æ¯å€‹é …ç›®
                selectedItems.forEach(item => {
                    // â­ ç¸®æ”¾æ•¸å­¸å…¬å¼
                    if (item.tool === 'formula') {
                        const oldCenterX = item.x + item.width / 2;
                        const oldCenterY = item.y + item.height / 2;
                        
                        // ç¸®æ”¾å°ºå¯¸
                        item.width *= ratio;
                        item.height *= ratio;
                        
                        // é‡æ–°è¨ˆç®—ä½ç½®ï¼ˆä¿æŒç›¸å°æ–¼ä¸­å¿ƒé»çš„ä½ç½®ï¼‰
                        item.x = centerX + (oldCenterX - centerX) * ratio - item.width / 2;
                        item.y = centerY + (oldCenterY - centerY) * ratio - item.height / 2;
                        
                        // æ›´æ–°åŸå§‹é™£åˆ—
                        if (item.sourceArray === 'strokes' && item.index >= 0 && item.index < strokes.length) {
                            strokes[item.index].x = item.x;
                            strokes[item.index].y = item.y;
                            strokes[item.index].width = item.width;
                            strokes[item.index].height = item.height;
                        }
                        
                        console.log('  âœ… ç¸®æ”¾æ•¸å­¸å…¬å¼:', item.id, 'â†’', item.width.toFixed(1), 'x', item.height.toFixed(1));
                    }
                    // ç¸®æ”¾åœ–ç‰‡
                    else if (item.tool === 'image') {
                        const oldCenterX = item.x + item.width / 2;
                        const oldCenterY = item.y + item.height / 2;
                        
                        item.width *= ratio;
                        item.height *= ratio;
                        item.x = centerX + (oldCenterX - centerX) * ratio - item.width / 2;
                        item.y = centerY + (oldCenterY - centerY) * ratio - item.height / 2;
                        
                        if (item.sourceArray === 'images' && item.index >= 0 && item.index < images.length) {
                            images[item.index].x = item.x;
                            images[item.index].y = item.y;
                            images[item.index].width = item.width;
                            images[item.index].height = item.height;
                        }
                        
                        console.log('  âœ… ç¸®æ”¾åœ–ç‰‡:', item.width.toFixed(1), 'x', item.height.toFixed(1));
                    }
                    // ç¸®æ”¾ç­†ç•«
                    else if (item.tool === 'stroke' && item.points) {
                        item.points.forEach(point => {
                            // ç›¸å°æ–¼ä¸­å¿ƒé»ç¸®æ”¾
                            point.x = centerX + (point.x - centerX) * ratio;
                            point.y = centerY + (point.y - centerY) * ratio;
                        });
                        
                        if (item.sourceArray === 'strokes' && item.index >= 0 && item.index < strokes.length) {
                            strokes[item.index].points = item.points;
                        }
                        
                        console.log('  âœ… ç¸®æ”¾ç­†ç•«:', item.points.length, 'é»');
                    }
                });
                
                // é‡ç¹ªç•«å¸ƒ
                redrawCanvas();
                
                const percentage = (ratio * 100).toFixed(0);
                addChatMessage('AI', `âœ… **ç¸®æ”¾å®Œæˆï¼**\n\nç¸®æ”¾æ¯”ä¾‹ï¼š${percentage}%\né¸ä¸­é …ç›®ï¼š${selectedItems.length} å€‹`);
            }
            
            // ç§»å‹•é¸ä¸­é …ç›®å‡½æ•¸
            function moveSelectedItems(deltaX, deltaY) {
                console.log('ğŸ”„ ç§»å‹•é …ç›®: Î”x=' + deltaX + ', Î”y=' + deltaY);

                selectedItems.forEach(item => {
                    // â­ ç§»å‹•æ•¸å­¸å…¬å¼
                    if (item.tool === 'formula') {
                        // æ›´æ–° selectedItems ä¸­çš„æ•¸æ“š
                        item.x += deltaX;
                        item.y += deltaY;
                        
                        // æ›´æ–°åŸå§‹ strokes é™£åˆ—ä¸­çš„æ•¸æ“š
                        if (item.sourceArray === 'strokes' && item.index >= 0 && item.index < strokes.length) {
                            strokes[item.index].x = item.x;
                            strokes[item.index].y = item.y;
                            console.log('  âœ… ç§»å‹•æ•¸å­¸å…¬å¼:', item.id || `index ${item.index}`, 'â†’', item.x.toFixed(1), item.y.toFixed(1));
                        }
                    }
                    // ç§»å‹•åœ–ç‰‡é¡å…§å®¹
                    else if (item.tool === 'image') {
                        // æ›´æ–°selectedItemsä¸­çš„æ•¸æ“š
                        item.x += deltaX;
                        item.y += deltaY;
                        // æ›´æ–°åŸå§‹imagesæ•¸çµ„ä¸­çš„æ•¸æ“š
                        if (item.sourceArray === 'images' && item.index >= 0 && item.index < images.length) {
                            images[item.index].x = item.x;
                            images[item.index].y = item.y;
                        }
                        console.log('  âœ… ç§»å‹•åœ–ç‰‡:', item.x.toFixed(1), item.y.toFixed(1));
                    }
                    // ç§»å‹•ç­†ç•«é¡å…§å®¹
                    else if (item.tool === 'stroke' && item.points) {
                        // æ›´æ–°selectedItemsä¸­çš„æ•¸æ“š
                        item.points.forEach(point => {
                            point.x += deltaX;
                            point.y += deltaY;
                        });
                        // æ›´æ–°åŸå§‹strokesæ•¸çµ„ä¸­çš„æ•¸æ“š
                        if (item.sourceArray === 'strokes' && item.index >= 0 && item.index < strokes.length) {
                            strokes[item.index].points = item.points;
                        }
                        console.log('  âœ… ç§»å‹•ç­†ç•«:', item.points.length + 'é»');
                    }
                });

                // ç«‹å³é‡ç¹ªç•«å¸ƒ
                redrawCanvas();
            }
            
            // ç²å–é¸å€ä¸­çš„é …ç›® (åœ–ç‰‡ã€ç­†ç•«ã€æ•¸å­¸å…¬å¼)
            function getItemsInSelection(selection) {
                const items = [];
                const overlapThreshold = 0.5; // â­ 50% é‡ç–Šåº¦é–¾å€¼

                console.log('ğŸ” é–‹å§‹æª¢æ¸¬é¸å€å…§çš„é …ç›®...');
                console.log('   é¸å€:', selection);

                // â­ æª¢æŸ¥æ‰€æœ‰åœ–ç‰‡ï¼ˆimages é™£åˆ—ï¼‰
                images.forEach((image, imageIndex) => {
                    const overlapRatio = getOverlapRatio(
                        {x: image.x, y: image.y, width: image.width, height: image.height},
                        selection
                    );
                    if (overlapRatio >= overlapThreshold) {
                        console.log(`   âœ… åœ–ç‰‡ ${imageIndex} é‡ç–Š ${(overlapRatio * 100).toFixed(1)}% - é¸ä¸­`);
                        items.push({
                            tool: 'image',
                            sourceArray: 'images',
                            index: imageIndex,
                            id: image.id,
                            x: image.x,
                            y: image.y,
                            width: image.width,
                            height: image.height,
                            imageData: image.imageData
                        });
                    } else {
                        console.log(`   âŒ åœ–ç‰‡ ${imageIndex} é‡ç–Š ${(overlapRatio * 100).toFixed(1)}% - æœªé¸ä¸­`);
                    }
                });

                // â­ æª¢æŸ¥æ‰€æœ‰ç­†ç•«ï¼ˆstrokes é™£åˆ—ï¼‰
                strokes.forEach((stroke, strokeIndex) => {
                    // è™•ç†æ•¸å­¸å…¬å¼ï¼ˆtool === 'image' æˆ–æœ‰ type === 'math_formula'ï¼‰
                    if (stroke.tool === 'image' || stroke.type === 'math_formula') {
                        // æ•¸å­¸å…¬å¼ï¼šä½¿ç”¨å¯¦éš›åœ–ç‰‡å€åŸŸ
                        const formulaBounds = {
                            x: stroke.x,
                            y: stroke.y,
                            width: stroke.width,
                            height: stroke.height
                        };
                        
                        const overlapRatio = getOverlapRatio(formulaBounds, selection);
                        if (overlapRatio >= overlapThreshold) {
                            console.log(`   âœ… æ•¸å­¸å…¬å¼ ${strokeIndex} (${stroke.id || 'unknown'}) é‡ç–Š ${(overlapRatio * 100).toFixed(1)}% - é¸ä¸­`);
                            items.push({
                                tool: 'formula',
                                sourceArray: 'strokes',
                                index: strokeIndex,
                                x: stroke.x,
                                y: stroke.y,
                                width: stroke.width,
                                height: stroke.height,
                                image: stroke.image,
                                id: stroke.id,
                                type: stroke.type,
                                originalLatex: stroke.originalLatex,
                                bounds: formulaBounds
                            });
                        } else {
                            console.log(`   âŒ æ•¸å­¸å…¬å¼ ${strokeIndex} (${stroke.id || 'unknown'}) é‡ç–Š ${(overlapRatio * 100).toFixed(1)}% - æœªé¸ä¸­`);
                        }
                    }
                    // è™•ç†æ™®é€šç­†ç•«ï¼ˆæœ‰ points é™£åˆ—ï¼‰
                    else if (stroke.points && Array.isArray(stroke.points) && stroke.points.length > 0) {
                        // è¨ˆç®—ç­†ç•«å…§æœ‰å¤šå°‘é»åœ¨é¸å€å…§
                        const pointsInSelection = stroke.points.filter(p => 
                            p.x >= selection.x && p.x <= selection.x + selection.width &&
                            p.y >= selection.y && p.y <= selection.y + selection.height
                        ).length;
                        
                        const pointOverlapRatio = pointsInSelection / stroke.points.length;
                        
                        if (pointOverlapRatio >= overlapThreshold) {
                    // è¨ˆç®—ç­†ç•«çš„é‚Šç•Œæ¡†
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    stroke.points.forEach(point => {
                        minX = Math.min(minX, point.x);
                        minY = Math.min(minY, point.y);
                        maxX = Math.max(maxX, point.x);
                        maxY = Math.max(maxY, point.y);
                    });

                        const strokeBounds = {
                            x: minX,
                            y: minY,
                            width: maxX - minX,
                            height: maxY - minY
                        };

                            console.log(`   âœ… ç­†ç•« ${strokeIndex} é‡ç–Š ${(pointOverlapRatio * 100).toFixed(1)}% (${pointsInSelection}/${stroke.points.length} é») - é¸ä¸­`);
                            items.push({
                                tool: 'stroke',
                                sourceArray: 'strokes',
                                index: strokeIndex,
                                id: stroke.id,
                                points: stroke.points,
                                color: stroke.color,
                                size: stroke.size,
                                bounds: strokeBounds
                            });
                        } else if (pointsInSelection > 0) {
                            console.log(`   âŒ ç­†ç•« ${strokeIndex} é‡ç–Š ${(pointOverlapRatio * 100).toFixed(1)}% (${pointsInSelection}/${stroke.points.length} é») - æœªé¸ä¸­`);
                        }
                    }
                });

                console.log(`ğŸ¯ é¸ä¸­ ${items.length} å€‹é …ç›®:`, items.map(i => `${i.tool}[${i.index}]`).join(', '));
                return items;
            }

            // è¨ˆç®—å…©å€‹çŸ©å½¢é‡ç–Šæ¯”ä¾‹çš„å·¥å…·å‡½æ•¸
            function getOverlapRatio(rect1, rect2) {
                const overlapX = Math.max(0, Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - Math.max(rect1.x, rect2.x));
                const overlapY = Math.max(0, Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - Math.max(rect1.y, rect2.y));
                const overlapArea = overlapX * overlapY;

                const rect1Area = rect1.width * rect1.height;
                const rect2Area = rect2.width * rect2.height;

                // è¿”å›ç›¸å°æ–¼è¼ƒå°çŸ©å½¢çš„é‡ç–Šæ¯”ä¾‹
                const smallerArea = Math.min(rect1Area, rect2Area);
                return smallerArea > 0 ? overlapArea / smallerArea : 0;
            }

            // ç¹ªåœ–å‡½æ•¸ (ç´”ç²¹ç•«ç•«)
            function draw(e) {
                if (!isDrawing) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.lineWidth = currentSize;
                ctx.strokeStyle = currentColor;
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                lastX = x;
                lastY = y;
                
                // æ·»åŠ é»åˆ°ç•¶å‰ç­†ç•«
                if (currentStroke) {
                    currentStroke.points.push({x: x, y: y});
                }
            }
            
        // é–‹å§‹ç¹ªåœ–
            function startDrawing(e) {
                if (!canvas || !ctx) return; // æª¢æŸ¥åˆå§‹åŒ–
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // ç¢ºä¿é¸æ“‡æ¨¡å¼é—œé–‰ï¼Œé–‹å§‹ç¹ªåœ–
                isSelecting = false;
                isDrawing = true;
                lastX = x;
                lastY = y;
                
                // é–‹å§‹æ–°ç­†ç•«
                currentStroke = {
                    tool: currentTool,
                    color: currentColor,
                    size: currentSize,
                    points: [{x: lastX, y: lastY}]
                };
            }
            
            // åœæ­¢ç¹ªåœ–
            function stopDrawing() {
                if (!canvas || !ctx) return;
                
                if (isDrawing && currentStroke) {
                    // â­ æ”¹ç”¨ Command Pattern
                    const command = new DrawStrokeCommand(currentStroke);
                    historyManager.execute(command);
                    currentStroke = null;
                    redrawCanvas(); // é‡ç¹ªä»¥é¡¯ç¤ºæ–°ç­†ç•«
                }
                isDrawing = false;
            }
            
        function initializeApp() {
            try {
                console.log('Starting app initialization...');
                
                // ç²å–ç•«å¸ƒå’Œä¸Šä¸‹æ–‡
                canvas = document.getElementById('drawing-canvas');
                if (!canvas) {
                    console.error('Canvas element not found!');
                    return;
                }
                ctx = canvas.getContext('2d');
                
                if (!ctx) {
                    console.error('Failed to get canvas context!');
                    return;
                }
            
            // è¨­å®šç•«å¸ƒå¤§å°
            function resizeCanvas() {
                if (!canvas) return;
                const container = canvas.parentElement;
                canvas.width = container.clientWidth - 4; // æ¸›å»é‚Šæ¡†
                canvas.height = container.clientHeight - 4;
                console.log('Canvas resized:', canvas.width, 'x', canvas.height);
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            

            
            // ç¶å®šç•«å¸ƒäº‹ä»¶ - çµ±ä¸€äº‹ä»¶è™•ç†
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('mouseout', handleCanvasMouseOut);
            
            // è§¸æ§äº‹ä»¶æ”¯æ´
            canvas.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                canvas.dispatchEvent(mouseEvent);
            });
            
            canvas.addEventListener('touchmove', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                canvas.dispatchEvent(mouseEvent);
            });
            
            canvas.addEventListener('touchend', function(e) {
                e.preventDefault();
                canvas.dispatchEvent(new MouseEvent('mouseup', {}));
            });
            
            // åœˆé¸æŒ‰éˆ• - è¡Œç‚ºé¡ä¼¼å·¥å…·åˆ‡æ›
            selectAreaBtn = document.getElementById('select-area-btn');
            if (selectAreaBtn) {
                selectAreaBtn.addEventListener('click', function() {
                    if (selectionOperation === 'select') {
                        setSelectionOperation(null); // å–æ¶ˆåœˆé¸
                    } else {
                        setSelectionOperation('select'); // æ¿€æ´»åœˆé¸
                    }
                });
            }
            
            // å·¥å…·æŒ‰éˆ•
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', function() {
                    // å–æ¶ˆåœˆé¸æ¨¡å¼ï¼ˆå¦‚æœæ¿€æ´»ï¼‰
                    if (isReadyToSelect && selectAreaBtn) {
                        isReadyToSelect = false;
                        selectAreaBtn.style.background = '#95a5a6';  // æ¢å¾©ç°åº•
                        console.log('âŒ åˆ‡æ›å·¥å…·ï¼Œå–æ¶ˆåœˆé¸æ¨¡å¼');
                    }
                    
                    // å·¥å…·åˆ‡æ›
                    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentTool = this.dataset.tool;
                    console.log('Tool changed to:', currentTool);
                });
            });
            
            // é¡è‰²é¸æ“‡å™¨
            const colorPicker = document.getElementById('color-picker');
            if (colorPicker) {
                colorPicker.addEventListener('change', function() {
                    currentColor = this.value;
                    console.log('Color changed to:', currentColor);
                });
            } else {
                console.warn('color-picker not found, skipping color picker setup');
            }
            
            // é¡è‰²æ¨£æœ¬
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.addEventListener('click', function() {
                    currentColor = this.dataset.color;
                    colorPicker.value = currentColor;
                    console.log('Color changed to:', currentColor);
                });
            });
            
            // ç­†åˆ·å¤§å°
            const sizeSlider = document.getElementById('size-slider');
            const sizeDisplay = document.getElementById('size-display');
            if (sizeSlider && sizeDisplay) {
                sizeSlider.addEventListener('input', function() {
                    currentSize = parseInt(this.value);
                    sizeDisplay.textContent = currentSize + 'px';
                });
            } else {
                console.warn('size-slider or size-display not found, skipping size setup');
            }
            
            // â­ Undo æŒ‰éˆ•
            const undoBtn = document.getElementById('undo-btn');
            if (undoBtn) {
                undoBtn.addEventListener('click', function() {
                    if (historyManager.undo()) {
                        addChatMessage('AI', 'â†©ï¸ **å›ä¸Šä¸€æ­¥**');
                    } else {
                        addChatMessage('AI', 'âš ï¸ å·²ç¶“æ˜¯æœ€æ—©çš„ç‹€æ…‹äº†');
                    }
                });
            } else {
                console.warn('undo-btn not found, skipping undo button setup');
            }
            
            // â­ Redo æŒ‰éˆ•
            const redoBtn = document.getElementById('redo-btn');
            if (redoBtn) {
                redoBtn.addEventListener('click', function() {
                    if (historyManager.redo()) {
                        addChatMessage('AI', 'â¡ï¸ **é‡åš**');
                    } else {
                        addChatMessage('AI', 'âš ï¸ æ²’æœ‰å¯ä»¥é‡åšçš„æ“ä½œ');
                    }
                });
            } else {
                console.warn('redo-btn not found, skipping redo button setup');
            }
            
            // æ¸…é™¤æŒ‰éˆ•
            const clearBtn = document.getElementById('clear-btn');
            if (clearBtn) {
                clearBtn.addEventListener('click', function() {
                    if (!canvas || !ctx) {
                        console.error('Canvas not initialized');
                        return;
                    }
                    
                    // â­ æ”¹ç”¨ Command Pattern
                    const command = new ClearCanvasCommand();
                    historyManager.execute(command);
                    redrawCanvas(); // æ¸…é™¤å¾Œé‡ç¹ªï¼ˆé¡¯ç¤ºç©ºç™½ç•«å¸ƒï¼‰
                    
                    console.log('Canvas cleared');
                    addChatMessage('AI', 'ğŸ—‘ï¸ **ç•«å¸ƒå·²æ¸…é™¤ï¼**\n\næç¤ºï¼šæŒ‰ Ctrl+Z å¯ä»¥å¾©åŸæ¸…é™¤æ“ä½œã€‚');
                });
            } else {
                console.warn('clear-btn not found, skipping clear button setup');
            }
            
            // â­ æ›´æ–°æ­·å²è¨˜éŒ„ UI ç‹€æ…‹çš„å‡½æ•¸
            function updateHistoryUI() {
                if (undoBtn) {
                    undoBtn.disabled = !historyManager.canUndo();
                }
                if (redoBtn) {
                    redoBtn.disabled = !historyManager.canRedo();
                }
            }
            
            // åˆå§‹åŒ– UI ç‹€æ…‹
            updateHistoryUI();
            
            // åˆ†æåœ–åƒæŒ‰éˆ•
            const analyzeBtn = document.getElementById('analyze-btn');
            if (analyzeBtn) {
                analyzeBtn.addEventListener('click', function() {
                    analyzeDrawing();
                });
            } else {
                console.warn('analyze-btn not found, skipping analyze button setup');
            }
            
            // ä¸Šå‚³åœ–ç‰‡
            const uploadBtn = document.getElementById('upload-image-btn');
            const uploadInput = document.getElementById('image-upload-input');
            if (uploadBtn && uploadInput) {
                uploadBtn.addEventListener('click', function() {
                    uploadInput.click();
                });
                uploadInput.addEventListener('change', function() {
                    const file = this.files && this.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = () => {
                        const img = new Image();
                        img.onload = () => {
                            addImageToCanvas(img);
                        };
                        img.src = reader.result;
                    };
                    reader.readAsDataURL(file);
                    this.value = '';
                });
            }
            
            // å„²å­˜æŒ‰éˆ• (PNGä¸‹è¼‰)
            const saveBtn = document.getElementById('save-btn');
            if (saveBtn) {
                saveBtn.addEventListener('click', function() {
                try {
                    if (!canvas || !ctx) {
                        addChatMessage('AI', 'âŒ ç•«å¸ƒæœªåˆå§‹åŒ–ï¼Œç„¡æ³•ä¿å­˜ã€‚');
                        return;
                    }
                    
                    // æª¢æŸ¥ç•«å¸ƒæ˜¯å¦æœ‰å…§å®¹
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const pixels = imageData.data;
                    let hasContent = false;
                    for (let i = 3; i < pixels.length; i += 4) {
                        if (pixels[i] > 0) { // alpha channel
                            hasContent = true;
                            break;
                        }
                    }
                    
                    if (!hasContent) {
                        addChatMessage('AI', 'ğŸ“ ç•«å¸ƒæ˜¯ç©ºçš„ï¼è«‹å…ˆç•«ä¸€äº›å…§å®¹å†ä¸‹è¼‰ã€‚');
                        return;
                    }
                    
                    const dataURL = canvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.download = 'ui-corework-drawing-' + new Date().getTime() + '.png';
                    link.href = dataURL;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    console.log('Drawing saved as PNG');
                    addChatMessage('AI', 'ğŸ¨ æ‚¨çš„ä½œå“å·²ä¸‹è¼‰ç‚ºPNGæª”æ¡ˆï¼');
                } catch (error) {
                    console.error('Save PNG error:', error);
                    addChatMessage('AI', 'âŒ PNGä¸‹è¼‰å¤±æ•—ï¼š' + error.message);
                }
                });
            } else {
                console.warn('save-btn not found, skipping PNG save setup');
            }
            
            // ä¿å­˜åˆ°é …ç›®æŒ‰éˆ•
            const saveToProjectBtn = document.getElementById('save-to-project-btn');
            if (saveToProjectBtn) {
                saveToProjectBtn.addEventListener('click', function() {
                    saveDrawingToProject();
                });
            } else {
                console.warn('save-to-project-btn not found, skipping save-to-project setup');
            }
            
            // èŠå¤©åŠŸèƒ½
            const chatMessages = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const sendBtn = document.getElementById('send-btn');
            if (!chatMessages || !chatInput || !sendBtn) {
                console.warn('Chat elements missing, chat will be disabled');
            }
            
            // ç¶å®šèŠå¤©é€å‡ºï¼ˆæŒ‰éˆ•èˆ‡ Enterï¼‰
            if (sendBtn) {
                sendBtn.addEventListener('click', sendMessage);
            }
            if (chatInput) {
                chatInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });
            }
            

            
            function sendMessage() {
                const message = chatInput.value.trim();
                if (!message) return;
                
                addChatMessage('æ‚¨', message);
                chatInput.value = '';
                
                // æ™ºèƒ½ AI å›æ‡‰
                setTimeout(() => {
                    processAIMessage(message);
                }, 800);
            }
            
            // AI è¨Šæ¯è™•ç†å‡½æ•¸
            function processAIMessage(userMessage) {
                const message = userMessage.toLowerCase();
                
                // æª¢æŸ¥æ˜¯å¦è¦æ±‚æ•¸å­¸å…¬å¼è½‰æ›
                if (message.includes('math') || message.includes('å…¬å¼') || message.includes('æ•¸å­¸')) {
                    if (window.currentSelectionData) {
                        processMathFormula(window.currentSelectionData);
                        return;
                    } else {
                        addChatMessage('AI', 'è«‹å…ˆä½¿ç”¨é¸æ“‡å·¥å…·ï¼ˆğŸ”² é¸ï¼‰åœ¨ç•«å¸ƒä¸Šåœˆé¸åŒ…å«æ•¸å­¸å…¬å¼çš„å€åŸŸã€‚');
                        return;
                    }
                }
                
                // æª¢æŸ¥æ˜¯å¦è¦æ±‚å¿ƒæ™ºåœ–ç·¨è¼¯
                if (message.includes('mindmap') || message.includes('å¿ƒæ™ºåœ–') || message.includes('è…¦åœ–')) {
                    if (window.currentSelectionData) {
                        processMindMap(window.currentSelectionData);
                        return;
                    } else {
                        addChatMessage('AI', 'è«‹å…ˆä½¿ç”¨é¸æ“‡å·¥å…·ï¼ˆğŸ”² é¸ï¼‰åœ¨ç•«å¸ƒä¸Šåœˆé¸è¦è½‰æ›ç‚ºå¿ƒæ™ºåœ–çš„å€åŸŸã€‚');
                        return;
                    }
                }
                
                // æª¢æŸ¥æ˜¯å¦è¦æ±‚åˆ†æåœ–åƒ
                if (message.includes('åˆ†æ') || message.includes('è¾¨è­˜') || message.includes('è­˜åˆ¥') || message.includes('é€™æ˜¯ä»€éº¼')) {
                    analyzeDrawing();
                    return;
                }
                
                // æª¢æŸ¥æ˜¯å¦è¦æ±‚å°‹æ‰¾ç¯„ä¾‹
                if (message.includes('ç¯„ä¾‹') || message.includes('ä¾‹å­') || message.includes('åƒè€ƒ') || message.includes('æ‰¾') || message.includes('æœå°‹') || message.includes('ä¸Šç¶²')) {
                    const keywords = extractKeywords(message);
                    findDesignExamples(keywords);
                    return;
                }
                
                // æª¢æŸ¥æ˜¯å¦è¦æ±‚æ•™å­¸
                if (message.includes('æ•™') || message.includes('æ€éº¼') || message.includes('å¦‚ä½•')) {
                    provideDrawingTutorial(message);
                    return;
                }
                
                // é è¨­æ™ºèƒ½å›æ‡‰
                const intelligentResponses = [
                    'æˆ‘çœ‹åˆ°æ‚¨çš„è¨Šæ¯äº†ï¼æ‚¨å¯ä»¥ï¼š\nğŸ¨ ç¹¼çºŒåœ¨ç•«å¸ƒä¸Šå‰µä½œ\nğŸ” é»æ“Šã€Œåˆ†æåœ–åƒã€è®“æˆ‘åˆ†ææ‚¨çš„ä½œå“\nğŸ“š é»æ“Šã€Œå°‹æ‰¾ç¯„ä¾‹ã€ç²å–è¨­è¨ˆéˆæ„Ÿ',
                    'å¾ˆæ£’çš„æƒ³æ³•ï¼å¦‚æœæ‚¨éœ€è¦æˆ‘åˆ†æç•¶å‰çš„ç¹ªåœ–ï¼Œè«‹é»æ“Šã€Œåˆ†æåœ–åƒã€æŒ‰éˆ•ã€‚',
                    'æ‚¨å¯ä»¥å‘Šè¨´æˆ‘æ‚¨æƒ³è¦ç•«ä»€éº¼ï¼Œæˆ‘å¯ä»¥ç‚ºæ‚¨æ‰¾åˆ°ç›¸é—œçš„è¨­è¨ˆç¯„ä¾‹å’Œæ•™å­¸ã€‚',
                    'è©¦è©¦çœ‹åœ¨ç•«å¸ƒä¸Šç•«ä¸€äº›å½¢ç‹€ï¼Œç„¶å¾Œè®“æˆ‘åˆ†æä¸¦æä¾›æ”¹é€²å»ºè­°ï¼',
                    'å¦‚æœæ‚¨æƒ³è¦ç‰¹å®šçš„è¨­è¨ˆéˆæ„Ÿï¼Œè«‹å‘Šè¨´æˆ‘æ‚¨è¦è¨­è¨ˆä»€éº¼é¡å‹çš„ç•Œé¢å…ƒç´ ã€‚'
                ];
                const response = intelligentResponses[Math.floor(Math.random() * intelligentResponses.length)];
                addChatMessage('AI', response);
            }
            
            // æå–é—œéµè©
            function extractKeywords(message) {
                const uiElements = ['æŒ‰éˆ•', 'button', 'è¡¨å–®', 'form', 'å°èˆª', 'nav', 'å¡ç‰‡', 'card', 'åœ–æ¨™', 'icon', 'èœå–®', 'menu'];
                const found = uiElements.filter(keyword => message.includes(keyword));
                return found.length > 0 ? found[0] : 'ç•Œé¢è¨­è¨ˆ';
            }
            
            // ä¿å­˜ç¹ªåœ–åˆ°é …ç›®
            function saveDrawingToProject() {
                if (!canvas || !ctx) {
                    addChatMessage('AI', 'âŒ ç•«å¸ƒæœªåˆå§‹åŒ–ï¼Œç„¡æ³•ä¿å­˜ã€‚');
                    return;
                }
                
                // æª¢æŸ¥ç•«å¸ƒæ˜¯å¦æœ‰å…§å®¹ (æ›´å¯é çš„æ–¹æ³•)
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = imageData.data;
                let hasContent = false;
                for (let i = 3; i < pixels.length; i += 4) {
                    if (pixels[i] > 0) { // alpha channel
                        hasContent = true;
                        break;
                    }
                }
                
                if (!hasContent) {
                    addChatMessage('AI', 'ğŸ“ ç•«å¸ƒæ˜¯ç©ºçš„ï¼è«‹å…ˆåœ¨ç•«å¸ƒä¸Šç•«ä¸€äº›å…§å®¹å†ä¿å­˜ã€‚');
                    return;
                }
                
                addChatMessage('AI', 'ğŸ’¾ æ­£åœ¨ä¿å­˜æ‚¨çš„ç¹ªåœ–åˆ°é …ç›®...');
                
                try {
                    // æº–å‚™ç¹ªåœ–æ•¸æ“š
                    const drawingData = {
                        id: 'drawing_' + new Date().getTime(),
                        title: 'Drawing ' + new Date().toLocaleString(),
                        image_data: canvas.toDataURL('image/png'),
                        description: 'ç”¨æˆ¶ç¹ªè£½çš„è¨­è¨ˆè‰åœ–',
                        tags: ['drawing', 'sketch', 'ui-design'],
                        strokes: strokes || [],
                        canvas: {
                            width: canvas.width,
                            height: canvas.height
                        },
                        metadata: {
                            created_at: new Date().toISOString(),
                            tools_used: ['pen', 'eraser']
                        }
                    };
                    
                    // ç™¼é€åˆ°å¾Œç«¯
                    fetch('/api/drawings', {
                        method: 'POST',  
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(drawingData)
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('ç¶²è·¯å›æ‡‰éŒ¯èª¤: ' + response.status);
                        }
                        return response.json();
                    })
                    .then(result => {
                        if (result.id) {
                            console.log('Drawing saved to project:', result);
                            addChatMessage('AI', 'âœ… æ‚¨çš„ç¹ªåœ–å·²æˆåŠŸä¿å­˜åˆ°é …ç›®ï¼ID: ' + result.id);
                        } else {
                            console.error('Failed to save drawing:', result);
                            addChatMessage('AI', 'âŒ ä¿å­˜å¤±æ•—ï¼š' + (result.message || result.detail || 'æœªçŸ¥éŒ¯èª¤'));
                        }
                    })
                    .catch(error => {
                        console.error('Error saving drawing:', error);
                        addChatMessage('AI', 'âŒ ä¿å­˜æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š' + error.message);
                    });
                } catch (error) {
                    console.error('Error preparing drawing data:', error);
                    addChatMessage('AI', 'âŒ æº–å‚™è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š' + error.message);
                }
            }
            
            // åˆ†æç¹ªåœ– - çœŸå¯¦ AI åˆ†æ
            function analyzeDrawing() {
                if (!canvas || !ctx) {
                    addChatMessage('AI', 'âŒ ç•«å¸ƒæœªåˆå§‹åŒ–ï¼Œç„¡æ³•åˆ†æã€‚');
                    return;
                }
                
                addChatMessage('AI', 'ğŸ” æ­£åœ¨æº–å‚™åœ–åƒé€²è¡Œ AI åˆ†æ...');
                
                // ç²å–ç•«å¸ƒæ•¸æ“š
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = imageData.data;
                
                // æª¢æŸ¥æ˜¯å¦æœ‰å…§å®¹
                let hasContent = false;
                for (let i = 3; i < pixels.length; i += 4) {
                    if (pixels[i] > 0) { // alpha channel
                        hasContent = true;
                        break;
                    }
                }
                
                if (!hasContent) {
                    addChatMessage('AI', 'ğŸ“ æˆ‘çœ‹åˆ°ç•«å¸ƒæ˜¯ç©ºçš„ï¼è«‹å…ˆåœ¨ç•«å¸ƒä¸Šç•«ä¸€äº›å…§å®¹ï¼Œç„¶å¾Œæˆ‘å°±å¯ä»¥ç‚ºæ‚¨é€²è¡Œ AI åˆ†æäº†ã€‚');
                    return;
                }
                
                // å°‡ç•«å¸ƒè½‰æ›ç‚ºåœ–ç‰‡æ•¸æ“š
                // å…ˆå¡«å……ç™½è‰²èƒŒæ™¯ï¼Œé¿å…é€æ˜èƒŒæ™¯å½±éŸ¿ AI è­˜åˆ¥
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                
                const imageDataURL = canvas.toDataURL('image/png');
                
                addChatMessage('AI', 'ğŸ¤– æ­£åœ¨èª¿ç”¨ AI æ¨¡å‹åˆ†ææ‚¨çš„ç¹ªåœ–...');
                
                // ç™¼é€åˆ°å¾Œç«¯é€²è¡ŒçœŸå¯¦ AI åˆ†æ
                const headers = {
                    'Content-Type': 'application/json',
                    ...AIConfig.getHeaders()
                };
                
                console.log('ğŸ“¤ ç™¼é€åˆ†æè«‹æ±‚ï¼ŒHeaders:', headers);
                
                fetch('/api/analyze-image', {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        image_data: imageDataURL,
                        prompt: "è«‹åˆ†æé€™å€‹UIè¨­è¨ˆè‰åœ–ï¼Œè­˜åˆ¥å…¶ä¸­çš„å…ƒç´ ï¼ˆå¦‚æŒ‰éˆ•ã€è¡¨å–®ã€å°èˆªç­‰ï¼‰ï¼Œè©•ä¼°è¨­è¨ˆçš„å„ªç¼ºé»ï¼Œä¸¦æä¾›å…·é«”çš„æ”¹é€²å»ºè­°ã€‚"
                    })
                })
                .then(response => response.json())
                .then(result => {
                    if (result.success) {
                        addChatMessage('AI', 'ğŸ¨ **AI åœ–åƒåˆ†æçµæœï¼š**\n\n' + result.analysis);
                        
                        // å¦‚æœæœ‰ç›¸é—œç¯„ä¾‹æ¨è–¦
                        if (result.suggested_examples) {
                            setTimeout(() => {
                                addChatMessage('AI', 'ï¿½ æ ¹æ“šåˆ†æçµæœï¼Œè®“æˆ‘ç‚ºæ‚¨æ¨è–¦ç›¸é—œçš„è¨­è¨ˆç¯„ä¾‹...');
                                displayRelatedExamples(result.suggested_examples);
                            }, 1500);
                        }
                    } else {
                        addChatMessage('AI', 'âŒ æŠ±æ­‰ï¼ŒAI åˆ†æé‡åˆ°äº†å•é¡Œï¼š' + (result.error || 'æœªçŸ¥éŒ¯èª¤') + '\n\nğŸ“ ç›®å‰æä¾›åŸºæœ¬åˆ†æä½œç‚ºæ›¿ä»£...');
                        performBasicAnalysis();
                    }
                })
                .catch(error => {
                    console.error('AI åˆ†æéŒ¯èª¤:', error);
                    addChatMessage('AI', 'âŒ é€£æ¥ AI åˆ†ææœå‹™å¤±æ•—ï¼Œæä¾›åŸºæœ¬åˆ†æä½œç‚ºæ›¿ä»£...');
                    performBasicAnalysis();
                });
            }
            
            // åŸºæœ¬åˆ†æä½œç‚ºå¾Œå‚™æ–¹æ¡ˆ
            function performBasicAnalysis() {
                if (!canvas || !ctx) {
                    addChatMessage('AI', 'âŒ ç•«å¸ƒæœªåˆå§‹åŒ–ï¼Œç„¡æ³•é€²è¡ŒåŸºæœ¬åˆ†æã€‚');
                    return;
                }
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = imageData.data;
                
                let colorCount = new Set();
                let pixelCount = 0;
                
                for (let i = 3; i < pixels.length; i += 4) {
                    if (pixels[i] > 0) {
                        const r = pixels[i-3], g = pixels[i-2], b = pixels[i-1];
                        colorCount.add(`${r}-${g}-${b}`);
                        pixelCount++;
                    }
                }
                
                let analysis = 'ğŸ“Š **åŸºæœ¬åœ–åƒåˆ†æï¼š**\n\n';
                analysis += `ğŸ¨ æª¢æ¸¬åˆ° ${colorCount.size} ç¨®é¡è‰²\n`;
                analysis += `ğŸ“ ç¹ªè£½äº†ç´„ ${Math.round(pixelCount / 1000)} k å€‹åƒç´ \n\n`;
                
                analysis += 'ğŸ’¡ **è¨­è¨ˆå»ºè­°ï¼š**\n';
                if (colorCount.size === 1) {
                    analysis += 'â€¢ è€ƒæ…®å¢åŠ å°æ¯”è‰²ä¾†çªå‡ºé‡è¦å…ƒç´ \n';
                } else if (colorCount.size > 8) {
                    analysis += 'â€¢ è‰²å½©è¼ƒå¤šï¼Œå»ºè­°çµ±ä¸€è‰²å½©æ–¹æ¡ˆ\n';
                }
                analysis += 'â€¢ å¯ä»¥å˜—è©¦æ·»åŠ ä¸€äº›å¹¾ä½•å½¢ç‹€ä¾†çµ„ç¹”ä½ˆå±€\n';
                analysis += 'â€¢ è€ƒæ…®æ·»åŠ æ–‡å­—æ¨™ç±¤ä¾†èªªæ˜åŠŸèƒ½\n\n';
                analysis += 'ğŸ”§ **å‡ç´šæç¤ºï¼š** é€£æ¥ AI æ¨¡å‹å¾Œå¯ç²å¾—æ›´è©³ç´°çš„è¨­è¨ˆåˆ†æï¼';
                
                addChatMessage('AI', analysis);
            }
            
            // å°‹æ‰¾è¨­è¨ˆç¯„ä¾‹å‡½æ•¸
            function findDesignExamples(keywords) {
                addChatMessage('AI', `ğŸ” æ­£åœ¨ç‚ºæ‚¨æœå°‹ã€Œ${keywords}ã€ç›¸é—œçš„è¨­è¨ˆç¯„ä¾‹...`);
                
                setTimeout(() => {
                    const examples = [
                        `ğŸ’¡ **${keywords}è¨­è¨ˆå»ºè­°ï¼š**\n`,
                        'â€¢ ä¿æŒç°¡æ½”æ˜äº†çš„è¦–è¦ºå±¤æ¬¡',
                        'â€¢ ä½¿ç”¨ä¸€è‡´çš„è‰²å½©å’Œå­—é«”',
                        'â€¢ ç¢ºä¿è¶³å¤ çš„å°æ¯”åº¦å’Œå¯è®€æ€§',
                        'â€¢ éµå¾ªä½¿ç”¨è€…çš„æ“ä½œç¿’æ…£',
                        '\nğŸ¨ **æ¨è–¦åƒè€ƒï¼š**',
                        'â€¢ Material Design è¨­è¨ˆè¦ç¯„',
                        'â€¢ Apple Human Interface Guidelines',
                        'â€¢ å„ªç§€çš„è¨­è¨ˆä½œå“é›†ç¶²ç«™å¦‚ Dribbbleã€Behance',
                        '\nâœ¨ è«‹ç¹¼çºŒåœ¨ç•«å¸ƒä¸Šå‰µä½œï¼Œæˆ‘æœƒç‚ºæ‚¨æä¾›æ›´å…·é«”çš„å»ºè­°ï¼'
                    ].join('\n');
                    
                    addChatMessage('AI', examples);
                }, 1000);
            }
            
            // æä¾›ç¹ªåœ–æ•™å­¸å‡½æ•¸
            function provideDrawingTutorial(message) {
                addChatMessage('AI', 'ğŸ“š **ç¹ªåœ–æ•™å­¸æŒ‡å—ï¼š**\n\n' +
                    'ğŸ–±ï¸ **åŸºæœ¬æ“ä½œï¼š**\n' +
                    'â€¢ é»æ“Šä¸¦æ‹–å‹•æ»‘é¼ é€²è¡Œç¹ªåœ–\n' +
                    'â€¢ ä½¿ç”¨å³å´çš„é¡è‰²é¸æ“‡å™¨è®Šæ›´é¡è‰²\n' +
                    'â€¢ èª¿æ•´ç­†åˆ·å¤§å°æ»‘æ¡¿æ§åˆ¶ç·šæ¢ç²—ç´°\n' +
                    'â€¢ é»æ“Šã€Œæ¸…é™¤ã€é‡æ–°é–‹å§‹\n\n' +
                    'ğŸ¨ **è¨­è¨ˆæŠ€å·§ï¼š**\n' +
                    'â€¢ å…ˆç•«å¤§è‡´è¼ªå»“ï¼Œå†æ·»åŠ ç´°ç¯€\n' +
                    'â€¢ ä½¿ç”¨å°æ¯”è‰²çªå‡ºé‡è¦å…ƒç´ \n' +
                    'â€¢ ä¿æŒè¦–è¦ºå¹³è¡¡å’Œå°ç¨±\n' +
                    'â€¢ é©ç•¶ç•™ç™½è®“è¨­è¨ˆæ›´æ¸…æ™°\n\n' +
                    'ğŸ’¡ **UIè¨­è¨ˆå»ºè­°ï¼š**\n' +
                    'â€¢ æŒ‰éˆ•è¦æœ‰æ˜ç¢ºçš„é‚Šç•Œ\n' +
                    'â€¢ æ–‡å­—è¦æœ‰è¶³å¤ çš„å°æ¯”åº¦\n' +
                    'â€¢ éµå¾ªä¸€è‡´çš„è¨­è¨ˆèªè¨€\n\n' +
                    'âœ¨ é–‹å§‹å‰µä½œå§ï¼å®Œæˆå¾Œé»æ“Šã€Œåˆ†æåœ–åƒã€ç²å¾—å°ˆæ¥­å»ºè­°ã€‚');
            }
            
            // è¨­ç½®é¢æ¿èª¿æ•´åŠŸèƒ½
            setupPanelResizer();
            
            // åˆå§‹åŒ–æ¨¡å¼è¨­ç½®
            updateCanvasCursor();
            
            // â­ æ·»åŠ éµç›¤äº‹ä»¶ç›£è½å™¨ï¼ˆUndo/Redo å’Œ Escapeï¼‰
            document.addEventListener('keydown', function(e) {
                // === Ctrl+Z: Undo ===
                if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    if (historyManager.undo()) {
                        addChatMessage('AI', 'â†©ï¸ **å›ä¸Šä¸€æ­¥**');
                    } else {
                        addChatMessage('AI', 'âš ï¸ å·²ç¶“æ˜¯æœ€æ—©çš„ç‹€æ…‹äº†');
                    }
                    return;
                }
                
                // === Ctrl+Shift+Z æˆ– Ctrl+Y: Redo ===
                if ((e.ctrlKey && e.shiftKey && e.key === 'Z') || (e.ctrlKey && e.key === 'y')) {
                    e.preventDefault();
                    if (historyManager.redo()) {
                        addChatMessage('AI', 'â¡ï¸ **é‡åš**');
                    } else {
                        addChatMessage('AI', 'âš ï¸ æ²’æœ‰å¯ä»¥é‡åšçš„æ“ä½œ');
                    }
                    return;
                }
                
                // === Escape: å–æ¶ˆæ‰€æœ‰æ“ä½œæ¨¡å¼ ===
                if (e.key === 'Escape' || e.key === 'Esc') {
                    console.log('âš ï¸  æŒ‰ Escape å–æ¶ˆæ‰€æœ‰æ“ä½œæ¨¡å¼');
                    
                    // é‡ç½®æ‰€æœ‰ç‹€æ…‹è®Šæ•¸
                    isDrawing = false;
                        isSelecting = false;
                    isReadyToSelect = false;
                    isDragging = false;
                    isMoving = false;
                    isScaling = false;
                    isDeleting = false;
                    selectedItems = [];
                    selectionOperation = null;
                    
                    // â­ æ¸…é™¤ç¸®æ”¾ç›¸é—œç‹€æ…‹
                    scalingBounds = null;
                    scalingCorner = null;
                    scalingStartPoint = {x: 0, y: 0};
                    scalingInitialBounds = null;
                    scalingInitialItems = null;
                    
                    // é‡ç½®æ‰€æœ‰æŒ‰éˆ•æ¨£å¼ï¼ˆçµ±ä¸€ç°è‰²æœªå•Ÿç”¨ï¼‰
                    if (selectAreaBtn) selectAreaBtn.style.background = '#95a5a6';
                    if (moveBtn) moveBtn.style.background = '#95a5a6';
                    if (scaleBtn) scaleBtn.style.background = '#95a5a6';
                    if (deleteBtn) deleteBtn.style.background = '#95a5a6';
                    
                    // æ¸…é™¤é¸æ“‡
                        clearSelection();
                    
                    // æ›´æ–°æ¸¸æ¨™
                    updateCanvasCursor();
                    
                    addChatMessage('AI', 'âŒ **å·²å–æ¶ˆæ‰€æœ‰æ“ä½œæ¨¡å¼ï¼Œå›åˆ°ç¹ªåœ–æ¨¡å¼**');
                }
            });
            
            console.log('âœ… æ‡‰ç”¨åˆå§‹åŒ–å®Œæˆï¼ç•«ç•«å’Œåœˆé¸åŠŸèƒ½å°±ç·’');
            
            } catch (error) {
                console.error('Error initializing app:', error);
                alert('åˆå§‹åŒ–å¤±æ•—: ' + error.message);
            }
        }
        
        // ç§»å‹•æŒ‰éˆ• - ç§»å‹•æ¨¡å¼åˆ‡æ›
        moveBtn = document.getElementById('move-btn');
        if (moveBtn) {
            moveBtn.addEventListener('click', function() {
                if (selectionOperation === 'move') {
                    setSelectionOperation(null); // å–æ¶ˆç§»å‹•
                } else {
                    setSelectionOperation('move'); // æ¿€æ´»ç§»å‹•
                }
            });
        }

        // é¡¯ç¤ºé¸å–æ¨¡å¼å°è©±æ¡†
        function showSelectionModeDialog(selection) {
            const dialog = document.getElementById('selection-mode-dialog');
            dialog.style.display = 'flex';

            // è¨­ç½®äº‹ä»¶ç›£è½å™¨
            const objectSelectBtn = document.getElementById('object-select-btn');
            const preciseSelectBtn = document.getElementById('precise-select-btn');
            const cancelBtn = document.getElementById('cancel-selection-btn');

            // è‡¨æ™‚è®Šé‡å­˜å„²é¸æ“‡å€åŸŸ
            window.currentSelection = selection;

            // ç‰©ä»¶é¸å–æ¨¡å¼
            objectSelectBtn.onclick = function() {
                console.log('ğŸ“¦ é¸æ“‡ç‰©ä»¶é¸å–æ¨¡å¼');
                addChatMessage('AI', 'ğŸ“¦ **ç‰©ä»¶é¸å–æ¨¡å¼**\n\né¸å–å®Œæ•´çš„ç‰©ä»¶å–®ä½ï¼Œä¿æŒç‰©ä»¶å®Œæ•´æ€§');

                // åŸ·è¡Œç‰©ä»¶é¸å–é‚è¼¯
                selectedItems = getItemsInSelection(selection);
                console.log('ğŸ–ï¸ ç‰©ä»¶é¸å–æ¨¡å¼é¸ä¸­é …ç›®:', selectedItems.length, 'å€‹');

                if (selectedItems.length > 0) {
                    // â­ æª¢æŸ¥ç•¶å‰æ¨¡å¼
                    if (isDeleting) {
                        // åˆªé™¤æ¨¡å¼ï¼šåŸ·è¡Œåˆªé™¤
                        const command = new DeleteItemsCommand(selectedItems);
                        historyManager.execute(command);
                        redrawCanvas();
                        addChatMessage('AI', `ğŸ—‘ï¸ **å·²åˆªé™¤ ${selectedItems.length} å€‹ç‰©ä»¶**\n\nå¯ä½¿ç”¨ Ctrl+Z å¾©åŸ`);
                        
                        // é‡ç½®ç‹€æ…‹
                        isDeleting = false;
                        selectedItems = [];
                        selectionOperation = null;
                        if (deleteBtn) deleteBtn.style.background = '#95a5a6';
                        
                        dialog.style.display = 'none';
                        updateCanvasCursor();
                    } else if (isScaling) {
                        // ç¸®æ”¾æ¨¡å¼ï¼šè¨ˆç®—é‚Šç•Œæ¡†ä¸¦æº–å‚™æ‹–æ‹½ç¸®æ”¾
                        addChatMessage('AI', `âœ… é¸ä¸­äº† ${selectedItems.length} å€‹ç‰©ä»¶\n\nè«‹æ‹–æ‹½é‚Šç•Œæ¡†çš„**è§’è½**ä¾†ç¸®æ”¾`);
                        dialog.style.display = 'none';
                        
                        // è¨ˆç®—é‚Šç•Œæ¡†
                        calculateScalingBounds();
                        
                        // é‡ç¹ªç•«å¸ƒï¼ˆé¡¯ç¤ºé‚Šç•Œæ¡†ï¼‰
                        redrawCanvas();
                    } else {
                        // ç§»å‹•æ¨¡å¼ï¼šæº–å‚™æ‹–æ‹½
                    addChatMessage('AI', `âœ… é¸ä¸­äº† ${selectedItems.length} å€‹å®Œæ•´ç‰©ä»¶ï¼Œè«‹æ‹–æ‹½ç§»å‹•`);
                    updateCanvasCursor(); // æ›´æ–°ç‚ºç§»å‹•æ¸¸æ¨™
                        dialog.style.display = 'none';
                    }
                } else {
                    addChatMessage('AI', 'âŒ åœˆé¸å€åŸŸå…§æ²’æœ‰æ‰¾åˆ°å®Œæ•´çš„ç‰©ä»¶');
                dialog.style.display = 'none';
                }
            };

            // ç²¾ç¢ºåˆ‡å‰²æ¨¡å¼
            preciseSelectBtn.onclick = function() {
                console.log('âœ‚ï¸ é¸æ“‡ç²¾ç¢ºåˆ‡å‰²æ¨¡å¼');
                addChatMessage('AI', 'âœ‚ï¸ **ç²¾ç¢ºåˆ‡å‰²æ¨¡å¼**\n\næ­¤åŠŸèƒ½æ­£åœ¨é–‹ç™¼ä¸­ï¼Œç›®å‰åªèƒ½é€²è¡Œç‰©ä»¶é¸å–');

                // ç›®å‰å…ˆåŸ·è¡Œç‰©ä»¶é¸å–é‚è¼¯
                selectedItems = getItemsInSelection(selection);
                console.log('ğŸ–ï¸ ç²¾ç¢ºåˆ‡å‰²æ¨¡å¼é¸ä¸­é …ç›®:', selectedItems.length, 'å€‹');

                if (selectedItems.length > 0) {
                    addChatMessage('AI', `âœ… è‡¨æ™‚ä½¿ç”¨ç‰©ä»¶é¸å–ï¼šé¸ä¸­äº† ${selectedItems.length} å€‹é …ç›®ï¼Œè«‹æ‹–æ‹½ç§»å‹•`);
                    updateCanvasCursor(); // æ›´æ–°ç‚ºç§»å‹•æ¸¸æ¨™
                } else {
                    addChatMessage('AI', 'âŒ åœˆé¸å€åŸŸå…§æ²’æœ‰æ‰¾åˆ°å…§å®¹');
                }

                dialog.style.display = 'none';
            };

            // å–æ¶ˆæŒ‰éˆ•
            cancelBtn.onclick = function() {
                console.log('âŒ å–æ¶ˆé¸å–æ¨¡å¼é¸æ“‡');
                addChatMessage('AI', 'âŒ å·²å–æ¶ˆé¸å–æ“ä½œ');
                clearSelection();
                dialog.style.display = 'none';
                updateCanvasCursor(); // é‡ç½®æ¸¸æ¨™
            };

            // é»æ“ŠèƒŒæ™¯é—œé–‰
            dialog.onclick = function(e) {
                if (e.target === dialog) {
                    cancelBtn.click();
                }
            };
        }
        
        // ç¸®æ”¾æŒ‰éˆ• - ç¸®æ”¾æ¨¡å¼åˆ‡æ›
        scaleBtn = document.getElementById('scale-btn');
        if (scaleBtn) {
            scaleBtn.addEventListener('click', function() {
                if (selectionOperation === 'scale') {
                    setSelectionOperation(null); // å–æ¶ˆç¸®æ”¾
                } else {
                    setSelectionOperation('scale'); // æ¿€æ´»ç¸®æ”¾
                }
            });
        }
        
        // åˆªé™¤æŒ‰éˆ• - åˆªé™¤æ¨¡å¼åˆ‡æ›
        deleteBtn = document.getElementById('delete-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', function() {
                if (selectionOperation === 'delete') {
                    setSelectionOperation(null); // å–æ¶ˆåˆªé™¤
                } else {
                    setSelectionOperation('delete'); // æ¿€æ´»åˆªé™¤
                }
            });
        }
        
        // åˆå§‹åŒ– AI è¨­å®š
        initAISettings();
    </script>

    <!-- é¸å–æ¨¡å¼å°è©±æ¡† -->
    <div id="selection-mode-dialog" class="dialog-overlay" style="display: none;">
        <div class="dialog-content">
            <div class="dialog-header">
                <h3>é¸æ“‡é¸å–æ¨¡å¼</h3>
            </div>
            <div class="dialog-body">
                <p>è«‹é¸æ“‡å¦‚ä½•é¸å–åœˆé¸å€åŸŸå…§çš„å…§å®¹ï¼š</p>
                <div class="mode-options">
                    <button class="mode-btn" id="object-select-btn">
                        <div class="mode-icon">ğŸ“¦</div>
                        <div class="mode-title">ç‰©ä»¶é¸å–</div>
                        <div class="mode-desc">é¸å–å®Œæ•´çš„ç‰©ä»¶å–®ä½ï¼Œä¿æŒç‰©ä»¶å®Œæ•´æ€§</div>
                    </button>
                    <button class="mode-btn" id="precise-select-btn">
                        <div class="mode-icon">âœ‚ï¸</div>
                        <div class="mode-title">ç²¾ç¢ºåˆ‡å‰²</div>
                        <div class="mode-desc">ç²¾ç¢ºé¸å–å€åŸŸå…§çš„éƒ¨åˆ†å…§å®¹ï¼ˆé–‹ç™¼ä¸­ï¼‰</div>
                    </button>
                </div>
            </div>
            <div class="dialog-footer">
                <button class="btn btn-secondary" id="cancel-selection-btn">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
</body>
</html>